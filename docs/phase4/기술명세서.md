# Phase 4: 기술 명세서

이 문서는 Phase 4 계획을 실행하기 위한 구체적인 기술 스택, 라이브러리 버전, 공식 문서, 사용 예제를 상세히 기술합니다.

---

## 1. 전체 시스템 연동 환경

현재 시스템의 각 부분을 실행하고 검증하기 위한 기술 요소와 명령어, 관련 공식 문서입니다.

### 1.1. 백엔드 (Python)

- **ASGI 서버: `uvicorn`**
    - **설명:** FastAPI 애플리케이션을 실행하기 위한 고성능 ASGI 서버입니다.
    - **버전:** `0.23.2` 이상 (FastAPI 권장 버전)
    - **사용법:** 프로젝트 루트에서 실행
      ```bash
      python -m uvicorn backend.main:app --host 0.0.0.0 --port 8000 --reload
      ```
    - **공식 문서:** [https://www.uvicorn.org/](https://www.uvicorn.org/)

- **gRPC 라이브러리: `grpcio` & `grpcio-tools`**
    - **설명:** Python에서 gRPC 서버 및 클라이언트를 구현하기 위한 핵심 라이브러리입니다.
    - **버전:** `>=1.59.0` (최신 안정 버전 권장, 이전 버전 충돌을 해결하기 위해 업그레이드 필요)
    - **사용법:** 코드에 이미 통합되어 있으며, `.proto` 파일 변경 시 아래 명령어로 코드를 다시 생성합니다.
      ```bash
      # Python 코드 재생성
      python -m grpc_tools.protoc -I./backend/proto --python_out=./backend --grpc_python_out=./backend backend/proto/game.proto
      ```
    - **공식 문서:** [https://grpc.io/docs/languages/python/](https://grpc.io/docs/languages/python/)

### 1.2. 프록시 (Envoy)

- **gRPC-Web 프록시: `envoy`**
    - **설명:** 브라우저(gRPC-Web)와 백엔드 gRPC 서버 간의 프로토콜 변환을 처리하는 프록시입니다.
    - **버전:** `v1.28.0` 이상 (최신 안정 버전 권장)
    - **사용법:** 프로젝트 루트의 `envoy.yaml` 설정 파일을 사용하여 실행합니다.
      ```bash
      envoy -c envoy.yaml
      ```
    - **공식 문서:** [https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/filters/grpc_web_filter](https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/filters/grpc_web_filter)

### 1.3. 프론트엔드 (React)

- **빌드 도구: `vite`**
    - **설명:** 빠르고 효율적인 프론트엔드 개발 서버 및 빌드 도구입니다.
    - **버전:** `^5.0.0` (`arcade-clash/package.json` 참고)
    - **사용법:** `arcade-clash` 디렉토리에서 실행
      ```bash
      npm run dev
      ```
    - **공식 문서:** [https://vitejs.dev/](https://vitejs.dev/)

- **gRPC-Web 클라이언트: `nice-grpc-web`**
    - **설명:** `ts-proto`와 함께 사용하기 좋은 타입-세이프한 최신 gRPC-Web 클라이언트입니다.
    - **버전:** `^2.0.0` (`arcade-clash/package.json` 참고)
    - **사용법:** `arcade-clash/src/grpc/client.ts` 에서 클라이언트를 생성하고, 각 컴포넌트에서 이를 가져와 사용합니다.
      ```typescript
      // arcade-clash/src/grpc/client.ts
      import { createChannel, createClient } from "nice-grpc-web";
      import { GameServiceDefinition } from "./game";

      const channel = createChannel("http://localhost:8080"); // Envoy 프록시 주소
      export const gameClient = createClient(GameServiceDefinition, channel);
      ```
    - **공식 문서:** [https://github.com/deeplay-io/nice-grpc/tree/master/packages/nice-grpc-web](https://github.com/deeplay-io/nice-grpc/tree/master/packages/nice-grpc-web)

---

## 2. 캐릭터 스프라이트 구현 상세 명세

붉은색 사각형 플레이스홀더를 실제 캐릭터 애니메이션으로 대체하는 상세 방법입니다.

### 2.1. 기술 요약

- **핵심 기술:** CSS 스프라이트 애니메이션
- **원리:** 하나의 이미지 파일(스프라이트 시트)에 모든 애니메이션 프레임을 모아두고, CSS의 `background-position` 속성을 동적으로 변경하여 필요한 프레임만 보여주는 기법입니다.

### 2.2. 구현 단계

**1. 스프라이트 시트 및 메타데이터 준비**

- `arcade-clash/public/assets/characters/` 경로에 `ryu.png` 와 같은 캐릭터별 스프라이트 시트 이미지를 배치합니다.
- 각 캐릭터의 애니메이션 정보를 담은 JSON 파일을 생성합니다. 예를 들어 `arcade-clash/src/components/characterMetadata.json`:

  ```json
  {
    "ryu": {
      "spriteSheet": "/assets/characters/ryu.png",
      "frameWidth": 80, 
      "frameHeight": 120,
      "actions": {
        "idle": { "row": 0, "frames": 4 },
        "walk": { "row": 1, "frames": 6 },
        "punch": { "row": 2, "frames": 3 }
      }
    },
    "ken": {
      "spriteSheet": "/assets/characters/ken.png",
      "frameWidth": 80,
      "frameHeight": 120,
      "actions": {
        "idle": { "row": 0, "frames": 4 },
        "walk": { "row": 1, "frames": 5 },
        "kick": { "row": 3, "frames": 4 }
      }
    }
  }
  ```

**2. `Character.tsx` 컴포넌트 수정**

- `Character.tsx`가 `name`, `action`, `frame` props를 받아 동적으로 스타일을 계산하도록 수정합니다.

  ```tsx
  import React from 'react';
  import characterMetadata from './characterMetadata.json';

  interface CharacterProps {
    name: string;
    x: number;
    y: number;
    action: string;
    frame: number;
    direction: 'left' | 'right';
  }

  const Character: React.FC<CharacterProps> = ({ name, x, y, action, frame, direction }) => {
    const metadata = characterMetadata[name.toLowerCase() as keyof typeof characterMetadata];
    if (!metadata) return null;

    const actionMeta = metadata.actions[action as keyof typeof metadata.actions];
    // 유효하지 않은 action일 경우 idle 상태로 대체
    const currentActionMeta = actionMeta || metadata.actions.idle;

    const frameIndex = frame % currentActionMeta.frames;
    
    const style: React.CSSProperties = {
      position: 'absolute',
      // 캐릭터의 발이 x, y 좌표의 기준이 되도록 위치 보정
      left: `${x - metadata.frameWidth / 2}px`,
      top: `${y - metadata.frameHeight}px`,
      width: `${metadata.frameWidth}px`,
      height: `${metadata.frameHeight}px`,
      backgroundImage: `url(${metadata.spriteSheet})`,
      backgroundPosition: `-${frameIndex * metadata.frameWidth}px -${currentActionMeta.row * metadata.frameHeight}px`,
      transform: direction === 'left' ? 'scaleX(-1)' : 'scaleX(1)',
      imageRendering: 'pixelated', // 픽셀 아트가 흐려지지 않도록 설정
    };

    return <div style={style} />;
  };

  export default Character;
  ```

**3. `HUD.tsx` 에서 `Character` 컴포넌트 호출 수정**

- 플레이어의 방향(`direction`)을 계산하여 `Character` 컴포넌트에 전달합니다.

  ```tsx
  // HUD.tsx의 렌더링 부분
  const p1 = gameState.players[0];
  const p2 = gameState.players[1];
  
  // p1이 p2의 왼쪽에 있으면 오른쪽을, 아니면 왼쪽을 바라보게 함
  const p1Direction = p1 && p2 && p1.x < p2.x ? 'right' : 'left';
  const p2Direction = p1Direction === 'right' ? 'left' : 'right';

  return (
    // ...
    <>
      {p1 && <Character key={p1.id} {...p1} direction={p1Direction} />}
      {p2 && <Character key={p2.id} {...p2} direction={p2Direction} />}
    </>
    // ...
  );
  ```

---

## 3. 플레이어 조작 구현 상세 명세

키보드 입력을 받아 백엔드로 전송하는 기능의 상세 명세입니다.

- **gRPC 방식:** Client-side Streaming RPC
- **원리:** 프론트엔드에서 키보드 이벤트가 발생할 때마다 `PlayerInput` 메시지를 스트림을 통해 백엔드로 계속 전송합니다.

### 3.1. `game.proto` 파일 확장

- `GameService`에 `StreamPlayerInput` RPC를 추가하고, `PlayerInput` 메시지를 정의합니다.

  ```protobuf
  // game.proto

  // ... 기존 GameService 위에 추가
  service ControllService {
      // 클라이언트 스트리밍 RPC: 플레이어 입력을 지속적으로 서버에 전송
      rpc StreamPlayerInput(stream PlayerInput) returns (google.protobuf.Empty);
  }

  message PlayerInput {
      int32 player_id = 1; // 조작하는 플레이어의 ID (e.g., 1)
      enum KeyAction {
          PRESS = 0;
          RELEASE = 1;
      }
      KeyAction key_action = 2; // 키 누름 또는 뗌
      string key = 3; // 입력된 키 (e.g., "ArrowUp", "a")
  }
  ```
  > **참고:** `google/protobuf/empty.proto` 를 사용하기 위해 `protoc` 실행 시 `--proto_path`에 Google의 공용 proto 파일 경로를 추가해야 할 수 있습니다.

### 3.2. 프론트엔드 구현

- 키보드 이벤트를 감지하고 gRPC 스트림으로 전송하는 로직을 추가합니다. (예: `GameInputProvider.tsx` 와 같은 컨텍스트로 구현)

  ```tsx
  // GameInputProvider.tsx (예시)
  import { controllClient } from '../src/grpc/client'; // ControllService 클라이언트 추가 필요

  const GameInputProvider = ({ children }) => {
    useEffect(() => {
      const inputStream = controllClient.streamPlayerInput();

      const handleKeyDown = (e: KeyboardEvent) => {
        inputStream.requests.send({ 
          playerId: 1, // 실제 플레이어 ID
          keyAction: 0, // PRESS
          key: e.key 
        });
      };

      const handleKeyUp = (e: KeyboardEvent) => {
        inputStream.requests.send({ 
          playerId: 1, 
          keyAction: 1, // RELEASE
          key: e.key 
        });
      };

      window.addEventListener('keydown', handleKeyDown);
      window.addEventListener('keyup', handleKeyUp);

      return () => {
        window.removeEventListener('keydown', handleKeyDown);
        window.removeEventListener('keyup', handleKeyUp);
        inputStream.requests.close();
      };
    }, []);

    return <>{children}</>;
  }
  ```

### 3.3. 백엔드 구현

- `ControllService`를 구현하여 클라이언트로부터 들어오는 입력 스트림을 처리하고, 이를 `GameRunner`에 전달하여 게임 상태에 반영합니다.

