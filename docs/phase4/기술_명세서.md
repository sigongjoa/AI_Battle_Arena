# Phase 4 기술 명세서: 커스텀 시그널링 기반 WebRTC 환경

## 1. 개요
이 문서는 Python FastAPI 백엔드가 직접 시그널링 서버 역할을 수행하는 'PeerJS-free' 아키텍처의 상세 기술 명세를 정의한다. `aiortc`를 사용하는 백엔드와 순수 WebRTC API를 사용하는 프론트엔드 간의 통신 방식, 데이터 모델, API를 포함한다.

---

## 2. 시스템 아키텍처 및 통신 패턴

### 2.1. 커스텀 시그널링 서버 (Custom Signaling Server)
-   **아키텍처**: 기존 `backend/main.py`의 FastAPI 애플리케이션에 WebSocket 엔드포인트(`/ws/{peer_id}`)를 추가하여 시그널링 서버 기능을 통합한다. **별도의 `PeerJS` 서버는 더 이상 필요하지 않다.**
-   **역할**: 두 Peer(백엔드 RL 에이전트, 프론트엔드 게임 클라이언트) 간의 WebRTC 연결 설정을 위한 메시지(SDP Offer/Answer, ICE Candidate)를 중계한다.
-   **구현**: 연결된 클라이언트 목록을 딕셔너리(`connected_peers`)로 관리하며, 수신한 메시지의 `dst` 필드를 기반으로 상대방에게 메시지를 전달하는 단순 릴레이(Relay) 서버로 동작한다.

### 2.2. 동기-비동기 브릿지 (Sync-Async Bridge)
-   `FightingEnv`와 `WebRTCClient` 간의 통신은 이전과 동일하게 **별도 스레드와 큐(Queue)를 사용하는 '브릿지' 패턴**을 유지하여, 동기적인 RL 라이브러리와 비동기 네트워크 통신을 안정적으로 연동한다.

---

## 3. 데이터 모델 및 프로토콜

### 3.1. 시그널링 프로토콜 (WebSocket API)
-   FastAPI의 `/ws/{peer_id}` 엔드포인트를 통해 교환되는 시그널링 메시지.

| `type` | `src` | `dst` | `payload` | 설명 |
| :--- | :--- | :--- | :--- | :--- |
| `offer` | Frontend | Backend | `RTCSessionDescription` | 프론트엔드가 연결을 제안하며 보냄 |
| `answer`| Backend | Frontend | `RTCSessionDescription` | 백엔드가 `offer`에 응답하며 보냄 |
| `candidate`| 양방향 | 상대방 | `RTCIceCandidate` | 네트워크 경로(ICE) 정보를 교환 |

### 3.2. 데이터 채널 프로토콜 (JSON API)
-   WebRTC 데이터 채널이 수립된 후 교환되는 메시지. (기존과 동일)
-   **백엔드 -> 프론트엔드**: `{ "type": "action", ... }`, `{ "type": "reset" }`
-   **프론트엔드 -> 백엔드**: `{ "type": "step_result", ... }`, `{ "type": "reset_result", ... }`, `{ "type": "connection_ready" }`

---

## 4. 백엔드 (Python) 명세

### 4.1. `WebRTCClient` 클래스 (`src/webrtc_client.py`)
-   **역할**: `aiortc`와 `aiohttp`를 사용하여 커스텀 시그널링 서버와 통신하고, WebRTC 연결을 관리한다.
-   **주요 로직**:
    -   `__init__`: `RTCPeerConnection` 객체를 생성한다.
    -   `connect`: `aiohttp`를 사용하여 FastAPI의 `/ws/{peer_id}` 엔드포인트에 WebSocket으로 접속한다.
    -   `handle_signaling`: WebSocket을 통해 `offer`를 수신하면, `setRemoteDescription`으로 적용하고, `createAnswer`를 생성하여 `setLocalDescription`으로 설정한 뒤, `answer` 메시지를 상대에게 전송한다.
    -   `on_datachannel`: 원격 Peer가 데이터 채널을 생성했을 때 호출되며, 메시지 핸들러 등을 설정한다.

### 4.2. `FightingEnv` 클래스 (`src/fighting_env.py`)
-   내부 로직은 변경 없음. `WebRTCClient`를 생성하고 큐를 통해 통신하는 기존 구조를 그대로 유지한다.

---

## 5. 프론트엔드 (TypeScript) 명세

### 5.1. `RLAgentController.tsx` 컴포넌트
-   **역할**: **`PeerJS` 라이브러리 의존성을 제거**하고, 순수 WebRTC API (`RTCPeerConnection`)와 `WebSocket`을 사용하여 백엔드와 통신한다.
-   **주요 로직**:
    1.  컴포넌트 마운트 시, `new WebSocket("ws://localhost:8001/ws/{frontend_peer_id}")`를 통해 시그널링 서버에 접속한다.
    2.  `RTCPeerConnection` 객체를 생성하고, 데이터 채널을 만든다 (`pc.createDataChannel(...)`).
    3.  `pc.createOffer()`를 통해 `offer`를 생성하고, `setLocalDescription`으로 설정한 뒤, WebSocket을 통해 백엔드로 전송한다.
    4.  WebSocket을 통해 백엔드로부터 `answer`를 수신하면, `setRemoteDescription`으로 설정을 완료한다.
    5.  이후 데이터 채널을 통해 게임 데이터를 교환한다.

---

## 6. 주요 의존성 및 버전

| 영역 | 라이브러리 | 역할 |
| :--- | :--- | :--- |
| Backend | `fastapi` | 메인 API 및 **시그널링 서버** |
| Backend | `uvicorn` | FastAPI 실행을 위한 ASGI 서버 |
| Backend | `aiortc` | Python WebRTC 엔진 |
| Backend | `aiohttp` | 시그널링용 비동기 WebSocket 클라이언트 |
| Frontend| `react` | UI 렌더링 |
| ~~Frontend~~ | ~~`peerjs`~~ | **(제거됨)** |