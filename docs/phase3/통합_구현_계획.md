# Phase 3: 백엔드-프론트엔드 통합 구현 계획

## 1. 목표

기존에 구현된 Python 기반의 게임 로직, 강화학습 환경(`fighting_env.py`), 학습 스크립트(`train_rl_agent.py`)를 `arcade-clash` React 프론트엔드와 연동합니다. 이를 통해 정적 데이터를 실제 백엔드 데이터로 대체하고, 실시간 시뮬레이션 및 학습 과정을 웹 UI에서 동적으로 시각화하는 것을 목표로 합니다.

## 2. 시스템 아키텍처

다음과 같은 3-Tier 아키텍처를 제안합니다.

1.  **프론트엔드 (React - `arcade-clash`)**: 사용자 인터페이스. 모든 데이터 요청 및 실시간 데이터 수신을 담당합니다.
2.  **백엔드 (Python - API Server)**: 프론트엔드와 게임/학습 로직을 중계하는 브릿지 서버. FastAPI 프레임워크 사용을 제안합니다.
3.  **핵심 로직 (Python)**:
    *   **게임 엔진**: Pygame 기반의 핵심 전투 시뮬레이션 로직.
    *   **강화학습**: Stable Baselines3 기반의 에이전트 학습 및 실행 환경.

![Architecture Diagram](https://i.imgur.com/9V5g42d.png)

## 3. 통신 프로토콜

프론트엔드와 백엔드는 다음 두 가지 방식으로 통신합니다.

*   **REST API (HTTP)**: 정적 또는 비동기적 데이터 요청에 사용됩니다. (예: 캐릭터 목록, 기술 목록 조회)
*   **WebSocket**: 실시간, 양방향 데이터 교환에 사용됩니다. (예: 실시간 게임 상태, 학습 메트릭 전송)

## 4. 화면별 통합 계획

`arcade-clash`의 각 화면을 백엔드와 연동하기 위한 구체적인 계획입니다.

### 가. `CharacterSelect` / `MoveList`
*   **목표**: 하드코딩된 캐릭터 및 기술 데이터를 백엔드 API에서 불러오도록 변경합니다.
*   **구현**:
    *   백엔드에서 다음 REST API 엔드포인트를 구현합니다.
        *   `GET /api/characters`: 모든 캐릭터의 목록과 상세 정보를 반환합니다.
        *   `GET /api/characters/{character_id}/moves`: 특정 캐릭터의 기술 목록을 반환합니다.
    *   프론트엔드에서는 `useEffect` hook을 사용하여 컴포넌트 마운트 시 `fetch`로 해당 API를 호출하고, 받아온 데이터로 상태를 업데이트합니다.

### 나. `HUD` (실시간 대전)
*   **목표**: 현재 프론트엔드의 무작위 시뮬레이션 로직을 실제 백엔드의 Pygame 시뮬레이션 결과로 대체합니다.
*   **구현**:
    *   백엔드는 WebSocket을 통해 특정 매치(`match_id`)에 대한 채널을 엽니다. (예: `/ws/game/{match_id}`)
    *   유저가 대전을 시작하면, 백엔드는 해당 Pygame 환경 인스턴스를 생성하고 게임 루프를 실행합니다.
    *   게임 루프의 매 틱(tick)마다 현재 게임 상태(플레이어 체력, 슈퍼 게이지, 위치, 현재 상태 등)를 JSON 형태로 WebSocket 채널에 전송(emit)합니다.
    *   프론트엔드의 `HUD` 컴포넌트는 이 WebSocket에 연결하고, 수신된 실시간 데이터에 맞춰 체력 바, 슈퍼 게이지 등 UI를 업데이트합니다.

### 다. `TrainingMode` (실시간 학습 현황)
*   **목표**: `SPECIFICATION.md`의 제안대로, 강화학습 진행 상황을 실시간으로 시각화합니다.
*   **구현**:
    *   백엔드는 학습 세션을 위한 WebSocket 채널을 엽니다. (예: `/ws/training/{session_id}`)
    *   `train_rl_agent.py` 스크립트를 수정하여, 학습 중 `Callback` 함수(예: `EvalCallback`) 내에서 `loss`, `reward`, `q-value` 등의 메트릭을 주기적으로 WebSocket 채널로 전송하도록 합니다.
    *   프론트엔드의 `TrainingMode` 컴포넌트는 이 WebSocket에 연결하고, 수신된 메트릭을 차트나 그래프 형태로 실시간 업데이트하여 보여줍니다.

### 라. `MatchupAnalysis` (AI 기반 분석)
*   **목표**: 보안 및 관심사 분리를 위해 Gemini API 호출을 백엔드로 이전합니다.
*   **구현**:
    *   백엔드에 `POST /api/analysis` 엔드포인트를 구현합니다. 이 엔드포인트는 두 캐릭터의 이름을 받아 Gemini API를 호출하고, 생성된 분석 텍스트를 반환합니다.
    *   프론트엔드는 이 API를 호출하여 결과를 받아 표시하기만 합니다. (API 키가 프론트엔드에 노출되지 않음)

## 5. 백엔드 구현 세부사항

*   **프레임워크**: **FastAPI**
    *   이유: ASGI 기반으로 WebSocket을 네이티브하게 지원하며, Pydantic을 이용한 타입 검증이 강력하고, 자동 API 문서 생성이 편리합니다.
*   **추천 라이브러리**:
    *   `uvicorn`: ASGI 서버
    *   `python-socketio`: WebSocket 관리
    *   `pygame`, `stable-baselines3`: 기존 로직 재사용
*   **프로젝트 구조 제안**:
    ```
    /AI_Battle_Arena/
    ├── arcade-clash/  (프론트엔드)
    ├── backend/       (신규 백엔드 디렉토리)
    │   ├── __init__.py
    │   ├── main.py      # FastAPI 앱 초기화, 라우터 등록
    │   ├── api/         # REST API 엔드포인트
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   ├── websockets/  # WebSocket 관련 로직
    │   │   ├── __init__.py
    │   │   └── handlers.py
    │   └── core/        # 게임, RL 로직 연동
    │       ├── __init__.py
    │       └── game_runner.py
    ├── src/           (기존 게임/RL 로직)
    └── ...
    ```

## 6. 실행 흐름

1.  **백엔드 서버 실행**: `backend` 디렉토리에서 `uvicorn main:app --reload` 명령어로 API 서버를 시작합니다.
2.  **프론트엔드 서버 실행**: `arcade-clash` 디렉토리에서 `npm run dev` 명령어로 React 개발 서버를 시작합니다.
3.  **사용자 접속**: 브라우저에서 프론트엔드 주소(`localhost:5173`)로 접속하면, 프론트엔드는 백엔드 서버(`localhost:8000`)와 통신하며 동적인 데이터를 렌더링합니다.

이 계획을 바탕으로 실제 개발을 진행할 수 있습니다. 각 단계별로 세부 구현 내용을 구체화하며 진행하는 것을 권장합니다.
