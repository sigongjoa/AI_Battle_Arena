# Phase 3: 기술 명세서

이 문서는 `arcade-clash` 백엔드-프론트엔드 통합을 위한 상세 기술 명세를 정의합니다.

## 1. 데이터 모델 (Data Transfer Objects)

백엔드와 프론트엔드 간에 교환될 데이터의 표준 모델(Pydantic 모델 기준)을 정의합니다.

```python
from pydantic import BaseModel
from typing import List, Optional

# 1.1. 캐릭터 정보
class MoveDTO(BaseModel):
    name: str
    description: str
    input: str
    frameData: str

class CharacterDTO(BaseModel):
    id: int
    name: str
    description: str
    image: str
    profileImage: str
    vsImage: str
    color: str
    moves: Optional[List[MoveDTO]] = None

# 1.2. 게임 상태 (WebSocket용)
class PlayerStateDTO(BaseModel):
    health: int
    super_gauge: int
    position: tuple[int, int] # (x, y)
    current_action: str # e.g., "IDLE", "WALK", "HADOKEN"

class GameStateDTO(BaseModel):
    match_id: str
    timer: int
    player1: PlayerStateDTO
    player2: PlayerStateDTO
    winner: Optional[int] = None # 승리한 플레이어의 id

# 1.3. 강화학습 메트릭 (WebSocket용)
class TrainingMetricsDTO(BaseModel):
    session_id: str
    step: int
    episode: int
    loss: float
    reward: float
    q_value: Optional[float] = None
    episode_length: int

# 1.4. 매치업 분석 (API용)
class MatchupRequest(BaseModel):
    player1_name: str
    player2_name: str

class MatchupResponse(BaseModel):
    player1_analysis: str
    player2_analysis: str
```

## 2. REST API 명세

**Base URL**: `http://localhost:8000`

### 2.1. 캐릭터 API

#### `GET /api/characters`
*   **설명**: 등록된 모든 캐릭터의 목록을 조회합니다.
*   **요청 본문**: 없음
*   **응답 본문 (200 OK)**:
    *   **타입**: `List[CharacterDTO]`
    *   **예시**:
        ```json
        [
            {
                "id": 1,
                "name": "Ryu",
                "description": "A wandering martial artist...",
                "image": "...",
                "profileImage": "...",
                "vsImage": "...",
                "color": "emphasis-yellow"
            }
        ]
        ```

#### `GET /api/characters/{character_id}/moves`
*   **설명**: 특정 캐릭터의 기술 목록을 조회합니다.
*   **경로 매개변수**: `character_id` (int)
*   **요청 본문**: 없음
*   **응답 본문 (200 OK)**:
    *   **타입**: `List[MoveDTO]`
    *   **예시**:
        ```json
        [
            {
                "name": "Hadoken",
                "description": "A powerful energy blast...",
                "input": "QCF + Punch",
                "frameData": "..."
            }
        ]
        ```
*   **오류 응답 (404 Not Found)**: 해당 `character_id`가 존재하지 않을 경우.

### 2.2. AI 매치업 분석 API

#### `POST /api/analysis`
*   **설명**: 두 캐릭터 간의 매치업 분석을 생성하고 하드코딩된 결과를 반환합니다. (Gemini API를 사용하지 않습니다.)
*   **요청 본문**:
    *   **타입**: `MatchupRequest`
    *   **예시**:
        ```json
        {
            "player1_name": "Ryu",
            "player2_name": "Ken"
        }
        ```
*   **응답 본문 (200 OK)**:
    *   **타입**: `MatchupResponse`
    *   **예시**:
        ```json
        {
            "player1_analysis": "Ryu는 Ken을 상대로 파동권을 활용하여 거리를 조절하는 것이 중요합니다...",
            "player2_analysis": "Ken은 빠른 접근과 강력한 승룡권으로 Ryu의 파동권을 무력화시킬 수 있습니다..."
        }
        ```

## 3. WebSocket API 명세

**Base URL**: `ws://localhost:8000`

### 3.1. 실시간 대전 채널

*   **네임스페이스**: `/ws/game/{match_id}`
*   **설명**: 두 플레이어 간의 실시간 게임 상태를 중계합니다.
*   **연결**: 프론트엔드에서 `HUD` 컴포넌트가 로드될 때, 고유한 `match_id`를 생성하여 해당 채널로 연결을 시도합니다.

#### 서버 -> 클라이언트 이벤트

*   **`event: game_state_update`**: 게임의 현재 상태를 주기적으로 전송합니다.
    *   **페이로드**: `GameStateDTO`

*   **`event: match_end`**: 매치가 종료되었음을 알립니다.
    *   **페이로드**: `{ "winner": 1 }` (승리한 플레이어의 ID, 무승부 시 `null`)

#### 클라이언트 -> 서버 이벤트

*   **`event: start_match`**: 게임 시작을 요청합니다.
    *   **페이로드**: `{ "player1_id": 1, "player2_id": 3 }`

### 3.2. 실시간 학습 현황 채널

*   **네임스페이스**: `/ws/training/{session_id}`
*   **설명**: 강화학습 에이전트의 학습 메트릭을 실시간으로 중계합니다.
*   **연결**: 프론트엔드에서 `TrainingMode` 컴포넌트가 로드될 때, 고유한 `session_id`를 생성하여 해당 채널로 연결을 시도합니다.

#### 서버 -> 클라이언트 이벤트

*   **`event: training_metrics_update`**: 학습 메트릭을 주기적으로 전송합니다.
    *   **페이로드**: `TrainingMetricsDTO`

*   **`event: training_end`**: 학습이 완료되었음을 알립니다.
    *   **페이로드**: `{ "message": "Training complete." }`

## 4. 백엔드 클래스 및 모듈 정의

### `main.py`
*   **역할**: FastAPI 애플리케이션의 진입점.
*   **주요 기능**: API 라우터 등록, WebSocket 엔드포인트 설정, CORS 미들웨어 설정.

### `api/routes.py`
*   **역할**: 모든 REST API 엔드포인트의 라우팅 및 로직을 처리합니다.
*   **주요 함수**:
    *   `get_all_characters()`: `GET /api/characters` 처리
    *   `get_character_moves()`: `GET /api/characters/{id}/moves` 처리
    *   `get_matchup_analysis()`: `POST /api/analysis` 처리

### `websockets/handlers.py`
*   **역할**: WebSocket 연결 및 이벤트 핸들링을 담당합니다.
*   **주요 클래스/함수**:
    *   `game_endpoint(websocket: WebSocket, match_id: str)`: `/ws/game/{match_id}` 엔드포인트. `GameRunner`를 생성하고 게임 루프를 시작시킵니다.
    *   `training_endpoint(websocket: WebSocket, session_id: str)`: `/ws/training/{session_id}` 엔드포인트. `TrainingManager`를 통해 학습을 시작하고 메트릭을 중계합니다.

### `core/game_runner.py`
*   **클래스**: `GameRunner`
*   **역할**: 단일 Pygame 게임 인스턴스를 관리하고 실행합니다.
*   **주요 메서드**:
    *   `__init__(self, websocket, player1_id, player2_id)`: 게임 환경 및 플레이어 초기화.
    *   `run()`: 별도의 스레드나 비동기 태스크에서 게임 루프를 실행. 매 틱마다 `fighting_env`를 업데이트하고, 상태를 `GameStateDTO`로 변환하여 WebSocket으로 전송.
    *   `stop()`: 게임 루프를 안전하게 종료.

### `core/training_manager.py`
*   **클래스**: `TrainingManager`
*   **역할**: 강화학습 세션을 관리합니다.
*   **주요 메서드**:
    *   `__init__(self, websocket, session_id)`: 학습 환경 및 모델 초기화.
    *   `start_training()`: `stable-baselines3`의 `learn()` 메서드를 호출하여 학습 시작. WebSocket으로 메트릭을 전송하는 커스텀 콜백을 등록.
