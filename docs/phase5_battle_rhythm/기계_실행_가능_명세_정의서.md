# 기계 실행 가능 명세(MES) 작성 가이드라인

## 1. 개요: '설명서'에서 '소스 코드'로

AI가 구현의 주체가 되는 프로젝트에서, 설계 문서는 더 이상 '인간 개발자를 위한 설명서'가 아니다. 이는 AI라는 '컴파일러'가 직접 해석하고 코드로 변환해야 하는 **'설계 소스 코드'**이다. 따라서, 본 가이드라인은 프로젝트의 모든 설계 문서가 '기계 실행 가능(Machine-Executable)' 수준의 구체성과 일관성을 갖추도록 하는 것을 목표로 한다.

'적절히', '유연하게'와 같은 모든 모호한 표현을 배제하고, 모든 로직과 상태 변화, 데이터 구조를 정형화된 방식으로 기술해야 한다.

---

## 2. 신규 필수 산출물 정의

모든 주요 기능 설계 시, 다음 두 가지 다이어그램을 필수로 작성하여 `기술_명세서.md`에 포함시켜야 한다.

### 2.1. 상태 머신 다이어그램 (State Machine Diagram)

-   **목적**: 특정 객체가 가질 수 있는 모든 **상태(State)**와, 한 상태에서 다른 상태로 **전환(Transition)**되는 조건(Condition) 및 행동(Action)을 시각적으로 명확하게 정의하여, 모든 분기 처리를 누락 없이 명세한다.
-   **대상**: `Player`, `GameRunner`, `WebRTCClient` 등 명확한 내부 상태를 가지는 모든 주요 객체.
-   **작성 도구**: **Mermaid.js** (Markdown 내에서 직접 작성 가능)
-   **작성 예시 (`Player` 객체)**:
    ```mermaid
    stateDiagram-v2
        [*] --> Idle

        Idle --> Walking : on key_press(move)
        Walking --> Idle : on key_release(move)
        Walking --> Jumping : on key_press(jump)
        Idle --> Jumping : on key_press(jump)
        Jumping --> Idle : on land_on_ground

        Idle --> Attacking : on key_press(attack)
        Walking --> Attacking : on key_press(attack)
        Attacking --> Idle : on animation_finished

        Idle --> Guarding : on key_press(guard)
        Walking --> Guarding : on key_press(guard)
        Guarding --> Idle : on key_release(guard)

        state HitStun {
            [*] --> Stunned
            Stunned --> Idle : on stun_timer_finished
        }

        Idle --> HitStun : on take_damage
        Walking --> HitStun : on take_damage
        Jumping --> HitStun : on take_damage
        Attacking --> HitStun : on take_damage
        Guarding --> HitStun : on guard_break
    ```

### 2.2. 시퀀스 다이어그램 (Sequence Diagram)

-   **목적**: 특정 유즈케이스 하에서 여러 객체/모듈이 어떤 순서로 메시지(함수 호출, 비동기 이벤트)를 주고받는지 시간의 흐름에 따라 명세한다. 이를 통해 비동기 통신에서의 Race Condition이나 Deadlock을 설계 단계에서 검증한다.
-   **대상**: `테스트_계획_및_성공_기준.md`에 기술된 모든 주요 유즈케이스.
-   **작성 도구**: **Mermaid.js**
-   **작성 예시 ('P2P WebRTC 연결 수립' 시나리오)**:
    ```mermaid
    sequenceDiagram
        participant ClientA as Player A
        participant Signaling as Signaling Server
        participant ClientB as Player B

        ClientA->>Signaling: request_match(B)
        Signaling->>ClientB: match_request_received(A)
        ClientB->>Signaling: accept_match(A)
        Signaling->>ClientA: match_accepted(B, peer_id_of_B)

        activate ClientA
        ClientA->>ClientB: Peer.connect(peer_id_of_B) via PeerServer
        deactivate ClientA

        activate ClientB
        Note right of ClientB: on('connection', conn)
        ClientB->>ClientA: DataChannel 'open' event
        deactivate ClientB

        par
            ClientA->>ClientB: GameInput Packets
        and
            ClientB->>ClientA: GameInput Packets
        end
    ```

---

## 3. 기존 문서 강화 지침

### 3.1. `기술_명세서.md`: 의사 코드(Pseudo-code) 의무화

모든 주요 함수의 명세는 단순 설명이 아닌, 즉시 코드로 변환 가능한 수준의 의사 코드를 포함해야 한다.

-   **Before (나쁜 예)**:
    > `applyExternalAction(action: number)`: RL 에이전트로부터 받은 action을 게임에 적용한다.

-   **After (좋은 예)**:
    ```
    function applyExternalAction(action: number):
      // Action 매핑은 `통신_프로토콜_명세서`의 'Action Enum' 참조
      switch action:
        case 0 (IDLE):
          // do nothing
        case 1 (MOVE_LEFT):
          player.velocity.x = -CHARACTER_MOVE_SPEED // 상수는 `캐릭터_명세서.json` 참조
          player.stateMachine.transitionTo('Walking') // 상태 전환은 `Player_StateMachine.puml` 참조
        case 2 (JUMP):
          if player.stateMachine.currentState is not 'Jumping':
             player.velocity.y = -CHARACTER_JUMP_FORCE
             player.stateMachine.transitionTo('Jumping')
        ...
    ```

### 3.2. `통신_프로토콜_명세서.md`: 정식 스키마(Formal Schema) 사용

모든 데이터 구조는 Markdown 테이블이 아닌, **Protocol Buffers** 또는 **JSON Schema**를 사용하여 정식으로 정의한다. 이를 통해 데이터 타입의 명확성을 보장하고, 유효성 검사 코드의 자동 생성을 가능하게 한다.

-   **Before (나쁜 예)**:
    > | 필드 | 타입 | 설명 |
    > |---|---|---|
    > | player1_x | number | 플레이어 1의 x좌표 |

-   **After (좋은 예)**:
    ```protobuf
    // in 통신_프로토콜_명세서.md

    syntax = "proto3";

    message Observation {
      float player1_x = 1;
      float player1_y = 2;
      float player1_hp = 3;
      int32 player1_state = 4; // Enum: 0=IDLE, 1=WALKING, ...
      // ...
    }
    ```

---

## 4. 결론

향후 모든 신규 기능 개발 및 기존 기능 수정은 본 `기계 실행 가능 명세(MES)` 가이드라인을 따른다. 모든 설계 문서는 AI 코드 생성기가 해석하는 데 모호함이 없도록, 상태 머신 다이어그램, 시퀀스 다이어그램, 의사 코드, 정식 스키마를 반드시 포함해야 한다.
