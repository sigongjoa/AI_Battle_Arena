# '전투의 리듬' 시스템 디자인 패턴 선정

## 1. 개요
이 문서는 '전투의 리듬' 기능 개발에 있어 시스템의 유연성, 확장성, 유지보수성을 극대화하기 위해 선정된 디자인 패턴을 기술한다. 각 패턴의 선정 이유와 적용 방식을 명시하여 아키텍처 설계의 근거를 명확히 한다.

---

## 2. 핵심 디자인 패턴

본 시스템은 단일 패턴이 아닌, 각 컴포넌트의 역할과 상호작용에 최적화된 여러 디자인 패턴의 조합으로 설계한다.

### 2.1. 옵저버 패턴 (Observer Pattern)

- **적용 대상**: `게임 루프(GameRunner)`와 `RhythmAnalyzer` 간의 관계.
- **선정 이유**: `RhythmAnalyzer`는 게임에서 발생하는 '행동(Action)'이라는 '이벤트'에 실시간으로 반응해야 한다. 옵저버 패턴은 이벤트 생성 주체(Subject, `GameRunner`)와 이벤트 처리 주체(Observer, `RhythmAnalyzer`)를 분리(Decoupling)하는 데 가장 이상적이다. 이를 통해 향후 `RhythmAnalyzer` 외에 또 다른 분석 모듈(Observer)이 추가되더라도, `GameRunner`의 코드를 전혀 수정할 필요 없이 새로운 모듈을 등록하는 것만으로 시스템을 확장할 수 있다.
- **구현 시나리오**:
    1. `GameRunner`는 `observers` 리스트를 관리하는 인터페이스를 가진다 (`register`, `unregister`, `notify`).
    2. `RhythmAnalyzer` 인스턴스는 생성 시점에 `GameRunner`의 `register` 메서드를 통해 스스로를 옵저버로 등록한다.
    3. `GameRunner`는 매 프레임 플레이어의 행동이 감지되면, `observers` 리스트를 순회하며 각 옵저버의 `update(action, frame)`와 같은 메서드를 호출한다.
    4. `RhythmAnalyzer`는 `update` 메서드가 호출되면, 전달받은 인자를 사용하여 자신의 `add_action` 메서드를 실행하고 내부 상태를 갱신한다.

### 2.2. 스트래티지 패턴 (Strategy Pattern)

- **적용 대상**: `RhythmAnalyzer`의 구체적인 '지표 계산' 알고리즘.
- **선정 이유**: '전투 리듬'을 분석하는 방법론은 고정되어 있지 않다. 현재의 지표(APM, 엔트로피 등) 외에 더 정교하거나, 완전히 다른 방식의 분석 알고리즘을 추가하거나 교체할 가능성이 높다. 스트래티지 패턴을 적용하면, 분석 알고리즘의 인터페이스를 정의하고 실제 구현은 별도의 '전략' 클래스로 캡슐화할 수 있다. 이를 통해 **알고리즘의 독립성을 보장하고, 런타임에도 동적으로 전략을 교체**하는 등 시스템의 유연성을 극대화할 수 있다.
- **구현 시나리오**:
    1. `analyze(action_log) -> dict` 메서드를 가진 `IRhythmAnalysisStrategy` 인터페이스를 정의한다.
    2. `BasicMetricsStrategy`, `AdvancedEntropyStrategy` 등 여러 구체적인 전략 클래스가 이 인터페이스를 구현한다.
    3. `RhythmAnalyzer`는 `IRhythmAnalysisStrategy` 타입의 객체를 속성으로 가지며, `get_metrics` 호출 시 이 전략 객체에 실제 계산을 위임한다.
    4. 필요에 따라 `RhythmAnalyzer`의 전략 객체를 다른 것으로 교체하여 분석 방식을 손쉽게 변경할 수 있다.

### 2.3. 파사드 패턴 (Facade Pattern)

- **적용 대상**: `FightingEnv` 클래스.
- **선정 이유**: 강화학습(RL) 에이전트의 입장에서, 게임의 모든 내부적인 복잡성(물리 엔진, 렌더링, 충돌 감지, 플레이어 객체 관리, 그리고 새로 추가된 리듬 분석 시스템 등)을 알 필요가 없다. `FightingEnv`는 이 모든 복잡한 서브시스템들을 하나의 계층 뒤로 감추고, AI 에이전트에게는 `step()`, `reset()`, `get_observation()` 이라는 **단순하고 일관된 상호작용 창구(API)만을 제공**한다. 이처럼 `FightingEnv`는 시스템의 복잡성을 효과적으로 숨기는 '파사드' 역할을 수행한다.

### 2.4. 데이터 전송 객체 패턴 (Data Transfer Object - DTO)

- **적용 대상**: 백엔드와 프론트엔드 간의 데이터 통신 (WebRTC 데이터 채널 메시지).
- **선정 이유**: 계층 간, 특히 네트워크를 통해 데이터를 전송할 때는 비즈니스 로직이 제거된 순수한 데이터 컨테이너를 사용하는 것이 효율적이고 안전하다. WebRTC를 통해 전송되는 JSON 메시지들이 DTO의 역할을 한다. 이는 **데이터의 형식을 명확하게 정의하고, 각 시스템 계층이 데이터 구조에 대해 동일한 이해를 갖도록 보장**한다.

---

## 3. 패턴 조합 시너지 요약

| 패턴 이름 | 적용 대상 | 목적 | 시너지 효과 |
| :--- | :--- | :--- | :--- |
| **옵저버** | `GameRunner` → `RhythmAnalyzer` | 이벤트 생성과 처리의 분리 | 스트래티지 패턴으로 구현된 다양한 분석기를 동적으로 추가/제거 가능. |
| **스트래티지** | `RhythmAnalyzer`의 분석 알고리즘 | 알고리즘의 캡슐화 및 교체 | 옵저버가 전달한 데이터를 다양한 방식으로 분석하는 실험이 용이. |
| **파사드** | `FightingEnv` | 복잡한 시스템에 대한 단순한 API 제공 | AI 에이전트는 내부 로직 변경(예: 분석 전략 변경)에 영향을 받지 않음. |
| **DTO** | 백엔드 ↔ 프론트엔드 통신 | 계층 간 데이터 전송 형식 표준화 | 명확한 데이터 계약(Contract)을 통해 프론트엔드와 백엔드 개발 병렬 진행. |

이러한 패턴들의 조합을 통해 '전투의 리듬' 시스템은 각 모듈의 책임이 명확하게 분리되고, 향후 기능 변경이나 확장에 유연하게 대처할 수 있는 견고한 아키텍처를 갖추게 된다.
