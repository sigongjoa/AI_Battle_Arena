# 구현 알고리즘 명세서

## 1. 개요

이 문서는 고수준의 기술 명세서와 실제 코드 구현 사이의 간극을 메우는 것을 목적으로 한다. 특정 함수 및 로직에 대해, AI 코드 생성기가 직접 코드로 변환할 수 있을 정도의 구체적인 알고리즘, 매핑 테이블, 의사 코드(Pseudo-code)를 제공한다.

첫 번째 대상은 `webrtc_rl_api_definitions.md`에서 정의된 `applyExternalAction(action: number)` 함수이다.

---

## 2. `applyExternalAction` 알고리즘 명세

### 2.1. 함수 시그니처 및 목적

-   **파일 위치**: `arcade-clash/shared_game_logic/engine.ts` (또는 관련 로직 파일)
-   **시그니처**: `function applyExternalAction(action: number): void;`
-   **목적**: RL 에이전트로부터 수신한 숫자 `action` 값을 실제 게임 내 플레이어의 행동으로 변환하여 실행한다.

### 2.2. 액션 ID - 함수 호출 매핑 테이블

AI가 사용하는 숫자 `action`과 `Player` 객체의 실제 메서드를 연결하는 규칙 테이블이다.

| `action` (number) | 상수 (Constant) | 호출 대상 함수 (Target Function Call) | 설명 |
| :--- | :--- | :--- | :--- |
| 0 | `ACTION_IDLE` | `player.move(0)` | 이동을 멈추고 기본 상태로 전환. | 
| 1 | `ACTION_MOVE_FORWARD` | `player.move(1)` | 캐릭터가 바라보는 방향으로 이동. | 
| 2 | `ACTION_MOVE_BACKWARD` | `player.move(-1)` | 캐릭터가 바라보는 반대 방향으로 이동. | 
| 3 | `ACTION_JUMP` | `player.jump()` | 점프. | 
| 4 | `ACTION_ATTACK_PRIMARY` | `player.attack('light_punch')` | 기본 공격 1 (예: 약한 펀치). | 
| 5 | `ACTION_ATTACK_SECONDARY`| `player.attack('heavy_kick')` | 기본 공격 2 (예: 강한 킥). | 
| 6 | `ACTION_GUARD` | `player.setGuarding(true)` | 가드 자세를 취함. | 

*참고: `player.setGuarding(false)`는 `ACTION_IDLE` 또는 다른 행동 시작 시 내부적으로 처리되어야 한다.*

### 2.3. 의사 코드 (Pseudo-code)

```
// 전역 변수 또는 상태 관리자에서 AI가 제어하는 플레이어 객체를 가져온다.
FUNCTION applyExternalAction(action_id as number):

    // 1. 제어 대상 플레이어 객체 획득
    player = GET_AI_CONTROLLED_PLAYER()

    // 2. 행동 불능 상태인지 확인
    // 피격 중, 스턴 상태 등에서는 새로운 행동을 할 수 없다.
    IF player.isUninterruptible() THEN
        RETURN // 함수 즉시 종료
    END IF

    // 3. 기존 가드 상태 해제 (새로운 행동 시작 전)
    // 점프나 이동 등 새로운 행동은 가드를 취소시킨다.
    IF action_id IS NOT ACTION_GUARD THEN
        player.setGuarding(false)
    END IF

    // 4. 액션 ID에 따라 분기
    SWITCH action_id:
        CASE 0 (ACTION_IDLE):
            player.move(0)
            BREAK

        CASE 1 (ACTION_MOVE_FORWARD):
            player.move(1)
            BREAK

        CASE 2 (ACTION_MOVE_BACKWARD):
            player.move(-1)
            BREAK

        CASE 3 (ACTION_JUMP):
            // player.jump() 메서드는 내부적으로 플레이어가 땅에 있는지 확인해야 함
            player.jump()
            BREAK

        CASE 4 (ACTION_ATTACK_PRIMARY):
            // player.attack() 메서드는 내부적으로 다른 공격 중인지 확인해야 함
            player.attack('light_punch')
            BREAK

        CASE 5 (ACTION_ATTACK_SECONDARY):
            player.attack('heavy_kick')
            BREAK

        CASE 6 (ACTION_GUARD):
            player.setGuarding(true)
            BREAK

        DEFAULT:
            // 정의되지 않은 Action ID에 대한 에러 로그 기록
            LOG_ERROR("Undefined action ID received: " + action_id)
            BREAK
    END SWITCH

END FUNCTION
```

### 2.4. 의존성 및 필수 선행 조건

이 알고리즘이 정상적으로 동작하기 위해, `Player` 클래스는 다음 인터페이스를 반드시 구현해야 한다.

-   `isUninterruptible(): boolean`: 현재 피격, 스턴 등 다른 행동으로 취소할 수 없는 상태인지 여부를 반환.
-   `move(direction: number)`: `direction` 값(1: 앞으로, -1: 뒤로, 0: 정지)에 따라 플레이어를 이동시킴.
-   `jump(): void`: 플레이어가 지상에 있을 경우, 점프 상태로 전환.
-   `attack(attackType: string): void`: `attackType`에 해당하는 공격을 시작. 다른 공격 중일 경우 무시.
-   `setGuarding(isGuarding: boolean)`: 플레이어의 가드 상태를 설정.

---

## 3. 다음 단계

-   위 의사 코드에 따라 `applyExternalAction` 함수의 실제 TypeScript 코드를 작성한다.
-   `Player` 클래스가 2.4절에 명시된 모든 메서드와 상태(예: `isUninterruptible`)를 가지도록 구현하거나 수정한다.
-   다른 모호한 함수들에 대해서도 이와 같은 방식의 알고리즘 명세를 점진적으로 추가해 나간다.
