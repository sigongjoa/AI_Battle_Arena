# P2P 대전 통신 프로토콜 명세서

## 1. 개요
이 문서는 AI Battle Arena의 실시간 P2P(Player-to-Player) 대전 통신 프로토콜을 상세히 정의한다. 격투 게임의 특성상 매우 낮은 지연 시간(Low Latency)과 입력의 일관성(Consistency)이 요구되므로, 본 프로토콜은 **롤백 넷코드(Rollback Netcode)** 아키텍처를 기반으로 설계되었다. 이 문서는 데이터 모델, 통신 흐름, 그리고 가장 중요한 **Race Condition 해결 방안**을 명확히 하는 것을 목표로 한다.

---

## 2. 핵심 아키텍처: 롤백 넷코드 (Rollback Netcode)

전통적인 'Lock-Step' 방식은 상대방의 다음 프레임 입력을 받을 때까지 게임을 멈추므로, 네트워크 지연(Latency)이 그대로 게임 지연(Lag)으로 이어진다. 격투 게임에서는 이는 치명적이다. 롤백 넷코드는 이 문제를 다음과 같이 해결한다.

1.  **입력 교환**: 양 클라이언트는 자신의 입력 상태를 매 프레임 상대방에게 전송한다. 이 입력 데이터에는 **어떤 프레임의 입력인지**를 나타내는 프레임 번호가 반드시 포함된다.
2.  **예측 실행 (Prediction)**: 상대방의 `N` 프레임 입력이 아직 도착하지 않았더라도, 게임을 멈추지 않는다. 대신, 상대방이 `N-1` 프레임의 입력을 그대로 유지할 것이라고 **예측**하고 시뮬레이션을 계속 진행한다.
3.  **롤백 및 재실행 (Rollback & Re-simulate)**: 뒤늦게 상대방의 `N` 프레임 실제 입력이 도착했을 때, 이전에 예측했던 값과 비교한다.
    -   **예측 성공**: 아무것도 하지 않는다.
    -   **예측 실패**: 게임의 상태를 `N` 프레임 시점으로 **되돌리고(Rollback)**, 올바른 입력을 적용하여 현재 프레임까지 **아주 빠른 속도로 재실행(Re-simulate)**한다. 이 과정은 화면 깜빡임 없이 순식간에 일어난다.

이 방식을 통해 플레이어는 네트워크 지연을 거의 느끼지 않고 항상 즉각적인 조작감을 경험할 수 있다.

---

## 3. Race Condition 해결 방안: 결정론적 실행 (Deterministic Execution)

Race Condition은 두 명의 플레이어가 같은 프레임에 입력했을 때(예: 동시에 펀치), 네트워크 상황에 따라 결과가 달라지는 현상을 말한다. 롤백 넷코드는 이 문제를 **'결정론적 게임 로직'** 으로 해결한다.

-   **단일 진실 공급원 (Single Source of Truth)**: 게임의 상태는 네트워크 도착 순서가 아니라, **'프레임 번호가 명시된 입력의 집합'** 이 유일한 진실의 공급원이다.
-   **결정론적 로직 (Deterministic Logic)**: 게임 시뮬레이션은 **100% 결정론적**으로 구현되어야 한다. 이는 동일한 프레임에 동일한 입력값이 주어지면, **언제 어디서 실행하든 반드시 100% 동일한 결과**가 나와야 함을 의미한다. (예: `random()` 함수 사용 금지, 부동소수점 연산 오차 주의)
-   **해결 과정**: 플레이어 A와 B가 100번 프레임에 동시에 펀치를 눌렀다고 가정하자.
    1.  A의 클라이언트에는 A의 입력이 즉시 반영되고, B의 입력은 예측 실행된다.
    2.  B의 클라이언트에는 B의 입력이 즉시 반영되고, A의 입력은 예측 실행된다.
    3.  잠시 후, A는 B의 100번 프레임 입력을, B는 A의 100번 프레임 입력을 수신한다.
    4.  양 클라이언트는 **'100번 프레임의 입력은 A:펀치, B:펀치'** 라는 동일한 사실을 알게 된다.
    5.  양 클라이언트는 즉시 100번 프레임 이전 상태로 롤백한 뒤, 확정된 입력값으로 재시뮬레이션한다. 결정론적 로직에 의해 두 클라이언트의 게임 상태는 완벽하게 동일해진다. **누가 먼저 입력했는지는 중요하지 않으며, 몇 번 프레임의 입력이었는지가 중요하다.**

---

## 4. 데이터 채널 프로토콜

기존 문서(`communication_protocol_and_code_spec.md`)의 정의를 기반으로, 롤백 넷코드에 맞게 데이터 모델을 구체화한다.

### 4.1. `GameInput` 채널 (핵심 채널)
-   **목적**: 플레이어의 입력을 매 프레임 전송.
-   **WebRTC 설정**: `ordered: false`, `maxRetransmits: 0` (비신뢰성, 비순서). 지연을 최소화하기 위함. 유실된 패킷은 다음 패킷에 포함된 정보로 복구되므로 재전송이 불필요하다.
-   **데이터 구조 (`InputPacket`)**:
    ```typescript
    interface InputPacket {
      type: 'input';
      startFrame: number;       // 이 패킷에 포함된 첫 입력의 프레임 번호
      inputs: InputState[];      // 실제 입력 데이터 배열
    }

    // 여러 프레임의 입력을 한 번에 보내 지연 및 패킷 유실에 대응
    interface InputState {
      // 예: { punch: true, kick: false, move: -1 }
      [inputName: string]: boolean | number;
    }
    ```

### 4.2. `Sync` 채널
-   **목적**: 비동기화(Desync) 감지 및 게임 상태 동기화를 위한 메시지 전송.
-   **WebRTC 설정**: `ordered: true` (신뢰성, 순서 보장).
-   **데이터 구조**:
    ```typescript
    // 주기적 체크섬 메시지 (예: 30프레임마다)
    interface ChecksumPacket {
      type: 'checksum';
      frame: number;
      checksum: string; // 해당 프레임의 게임 상태로부터 계산된 체크섬
    }

    // 비동기화 발생 시, 상태를 강제 동기화하기 위한 요청/응답
    interface StateRequestPacket {
      type: 'request_state';
      frame: number; // 특정 프레임의 상태를 요청
    }
    interface StateResponsePacket {
      type: 'response_state';
      frame: number;
      gameState: any; // 직렬화된 게임 상태 데이터
    }
    ```

---

## 5. 상세 데이터 흐름 (롤백 시나리오)

`P1`과 `P2`가 있고, 네트워크 지연이 2프레임이라고 가정.

1.  **Frame 100**:
    -   `P1`: `오른쪽 이동` 입력. 로컬에서 즉시 실행. `P2`는 `가만히 있음`(예측)으로 처리.
    -   `P2`: `펀치` 입력. 로컬에서 즉시 실행. `P1`은 `가만히 있음`(예측)으로 처리.
    -   `P1`은 `{frame: 100, input: '오른쪽'}` 패킷을 `P2`에게 전송.
    -   `P2`는 `{frame: 100, input: '펀치'}` 패킷을 `P1`에게 전송.

2.  **Frame 101** (예측 실행 지속):
    -   `P1`: 로컬에서 `오른쪽 이동` 지속. `P2`는 여전히 `가만히 있음`(예측).
    -   `P2`: 로컬에서 `펀치` 지속. `P1`은 여전히 `가만히 있음`(예측).

3.  **Frame 102** (수신 및 롤백):
    -   `P1`의 클라이언트가 `P2`의 100번 프레임 입력(`펀치`)을 수신.
    -   **예측 실패 감지**: `P1`은 `P2`가 `가만히 있을 것`이라 예측했지만, 실제는 `펀치`였음.
    -   **롤백**: `P1`의 게임 상태를 100번 프레임 직전으로 되돌림.
    -   **재실행**: `P1`은 확정된 입력 `{frame: 100, p1_input: '오른쪽', p2_input: '펀치'}`로 100번 프레임을 재실행. 이어서 101번 프레임도 재실행. 이제 `P1`의 102번 프레임 상태는 `P2`의 100번 프레임 행동이 올바르게 반영된 결과가 됨.
    -   `P2`의 클라이언트도 동일한 과정을 거치며, 두 클라이언트는 결국 같은 미래에 도달한다.
