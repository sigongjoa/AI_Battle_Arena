### **WebRTC 및 롤백 넷코드 아키텍처 시스템 플로우 및 유스 케이스 명세**

**목표:** WebRTC P2P 데이터 채널 및 롤백 넷코드 기반의 저지연 격투 게임 아키텍처에서 시스템의 전반적인 동작 흐름과 주요 사용자 시나리오를 정의합니다.

---

#### **1. 시스템 플로우 (System Flow)**

이 섹션에서는 플레이어가 게임을 시작하고 매치를 플레이하며 종료하는 전체 과정을 단계별로 설명합니다.

**1.1. 전체 시스템 아키텍처 다이어그램 (개념적 설명)**

*   **구성 요소:**
    *   **클라이언트 A, 클라이언트 B:** 게임을 플레이하는 사용자 기기 (프론트엔드).
    *   **시그널링 서버:** 매치메이킹 및 WebRTC 연결 협상을 중개하는 백엔드 서버.
    *   **STUN 서버:** 클라이언트의 공인 IP 주소 및 포트를 알려주는 서버.
    *   **TURN 서버:** 직접 P2P 연결이 불가능할 때 데이터 릴레이 역할을 하는 서버.
*   **흐름:**
    1.  **발견 (Discovery):** 클라이언트 A, B가 시그널링 서버에 WebSocket으로 연결.
    2.  **매치메이킹 (Matchmaking):** 시그널링 서버가 클라이언트 A, B를 매칭.
    3.  **협상 (Negotiation):** 클라이언트 A가 SDP Offer 생성 -> 시그널링 서버 경유 -> 클라이언트 B. 클라이언트 B가 SDP Answer 생성 -> 시그널링 서버 경유 -> 클라이언트 A. 이 과정에서 STUN/TURN 서버를 통해 ICE 후보 수집.
    4.  **핸드셰이크 (Handshake):** 클라이언트 A, B가 시그널링 서버를 통해 ICE 후보 교환.
    5.  **연결 (Connection):** 각 클라이언트의 WebRTC ICE 프레임워크가 최적의 P2P 경로를 설정. 시그널링 서버의 역할 종료.
    6.  **게임플레이 (Gameplay):** 클라이언트 A, B가 설정된 RTCDataChannel (GameInput, GameStateSync, Metadata)을 통해 직접 게임 데이터 교환. 각 클라이언트의 롤백 넷코드 엔진이 데이터를 처리하여 동기화된 시뮬레이션 유지.
    7.  **매치 종료 (Match End):** 게임 종료 조건 충족 시 매치 종료.

**1.2. 상세 플로우 다이어그램 (단계별 설명)**

**1.2.1. 플레이어 발견 및 로비 진입**

1.  **클라이언트:** 게임 실행 후 시그널링 서버 (`/ws/signal`)에 WebSocket 연결을 시도합니다.
2.  **클라이언트:** `join_lobby` 메시지를 시그널링 서버로 전송합니다 (플레이어 ID, 이름 포함).
3.  **시그널링 서버:** 새 연결을 등록하고, `lobby_update` 메시지를 로비의 모든 클라이언트에게 브로드캐스트하여 업데이트된 플레이어 목록을 알립니다.
4.  **클라이언트:** 로비 화면에 접속 가능한 플레이어 목록을 표시합니다.

**1.2.2. 매치메이킹 및 연결 협상**

1.  **클라이언트 A:** 로비에서 클라이언트 B를 선택하여 `request_match` 메시지를 시그널링 서버로 전송합니다. **(이때 고유한 `sessionId`를 생성하여 포함)**
2.  **시그널링 서버:** 클라이언트 B에게 `match_request_received` 메시지를 전송합니다. **(sessionId 포함)**
3.  **클라이언트 B:** 매치 요청을 수락하거나 거절합니다.
    *   **수락 시:** `accept_match` 메시지를 시그널링 서버로 전송합니다. **(sessionId 포함)**
    *   **거절 시:** `decline_match` 메시지를 시그널링 서버로 전송합니다. **(sessionId 포함)**
4.  **시그널링 서버:** 클라이언트 A에게 `match_request_accepted` 또는 `match_request_declined` 메시지를 전송합니다. **(sessionId 포함)**
5.  **매치 수락 시 (WebRTC 핸드셰이크 시작):**
    *   **클라이언트 A (개시자):** `RTCPeerConnection`을 생성하고, `createOffer()`를 호출하여 SDP Offer를 생성합니다.
    *   **클라이언트 A:** 생성된 SDP Offer를 `send_sdp_offer` 메시지로 시그널링 서버를 통해 클라이언트 B에게 전송합니다. **(sessionId 포함)**
    *   **클라이언트 A, B:** `RTCPeerConnection`의 `onicecandidate` 이벤트를 통해 ICE 후보를 수집하고, `send_ice_candidate` 메시지로 시그널링 서버를 통해 상대방에게 전송합니다. (Trickle ICE) **(sessionId 포함)**
    *   **클라이언트 B:** 수신된 SDP Offer를 `RTCPeerConnection`에 설정하고, `createAnswer()`를 호출하여 SDP Answer를 생성합니다.
    *   **클라이언트 B:** 생성된 SDP Answer를 `send_sdp_answer` 메시지로 시그널링 서버를 통해 클라이언트 A에게 전송합니다. **(sessionId 포함)**
    *   **클라이언트 A:** 수신된 SDP Answer를 `RTCPeerConnection`에 설정합니다.
    *   **클라이언트 A, B:** 모든 ICE 후보 교환 및 연결 협상이 완료되면, `RTCPeerConnection`의 `iceconnectionstate`가 `connected` 또는 `completed`로 변경됩니다.
6.  **시그널링 서버:** P2P 연결이 성공적으로 수립되면, 클라이언트 A, B에게 `match_started` 메시지를 전송하고, 해당 매치에 대한 시그널링 역할을 종료합니다. **(sessionId 포함)**

**1.2.3. 게임 플레이 (롤백 넷코드)**

1.  **클라이언트 A, B:** P2P 연결을 통해 `GameInput`, `GameStateSync`, `Metadata` 데이터 채널을 활성화합니다.
2.  **클라이언트 A, B:** 각자의 `GameEngine`은 고정된 타임스텝으로 게임 시뮬레이션을 실행합니다.
3.  **클라이언트 A:** 로컬 플레이어의 입력을 캡처하여 `GameInput` 채널을 통해 클라이언트 B에게 전송합니다.
4.  **클라이언트 A:** 다음 프레임을 시뮬레이션할 때, 아직 받지 못한 클라이언트 B의 입력은 마지막으로 알려진 입력으로 예측합니다.
5.  **클라이언트 B:** 로컬 플레이어의 입력을 캡처하여 `GameInput` 채널을 통해 클라이언트 A에게 전송합니다.
6.  **클라이언트 B:** 다음 프레임을 시뮬레이션할 때, 아직 받지 못한 클라이언트 A의 입력은 마지막으로 알려진 입력으로 예측합니다.
7.  **클라이언트 A (예시):**
    *   프레임 N에 대한 클라이언트 B의 실제 입력이 `GameInput` 채널을 통해 도착합니다.
    *   `GameEngine`은 프레임 N에 대한 예측된 입력과 실제 입력을 비교합니다.
    *   **불일치 발생 시:** `GameEngine`은 마지막으로 동기화된 프레임 (N-1)의 상태로 롤백하고, 클라이언트 A의 실제 입력과 클라이언트 B의 실제 입력을 사용하여 프레임 N부터 현재 프레임까지 재시뮬레이션합니다.
    *   **불일치 미발생 시:** 시뮬레이션을 계속 진행합니다.
8.  **클라이언트 A, B:** 주기적으로 `GameStateSync` 채널을 통해 게임 상태 체크섬을 교환하여 비동기화 여부를 확인합니다. **(보안/치트 방지를 위해 필수적)**
9.  **클라이언트 A, B:** `Metadata` 채널을 통해 채팅 메시지, 연결 끊김 알림 등을 교환합니다.

**1.2.4. 매치 종료**

1.  **클라이언트 A, B:** 게임 내 종료 조건 (예: 체력 고갈, 시간 초과)이 충족됩니다.
2.  **클라이언트 A, B:** `GameStateSync` 채널을 통해 "K.O." 또는 "Round End"와 같은 중요 이벤트 메시지를 교환합니다.
3.  **클라이언트 A, B:** 매치 결과 화면을 표시하고, `RTCPeerConnection`을 종료합니다.
4.  **클라이언트 A, B:** 다시 시그널링 서버에 연결하여 로비로 돌아갈 수 있습니다.

---

#### **2. 유스 케이스 (Use Cases)**

이 섹션에서는 시스템의 주요 사용자 상호작용 시나리오를 정의합니다.

**2.1. 핵심 유스 케이스**

*   **UC-001: 플레이어 로비 진입**
    *   **설명:** 사용자가 게임을 실행하고 온라인 로비에 접속하여 다른 플레이어를 확인합니다.
    *   **액터:** 플레이어, 시그널링 서버.
    *   **사전 조건:** 게임 클라이언트가 실행 중이고 인터넷에 연결되어 있습니다.
    *   **기본 흐름:**
        1.  플레이어가 게임을 시작합니다.
        2.  클라이언트가 시그널링 서버에 WebSocket 연결을 수립합니다.
        3.  클라이언트가 `join_lobby` 메시지를 전송합니다.
        4.  시그널링 서버가 연결을 등록하고 `lobby_update` 메시지를 브로드캐스트합니다.
        5.  클라이언트가 로비 화면에 접속 가능한 플레이어 목록을 표시합니다.
    *   **사후 조건:** 플레이어가 로비에 성공적으로 접속하고 다른 플레이어 목록을 볼 수 있습니다.

*   **UC-002: 플레이어 매치 요청 및 수락**
    *   **설명:** 플레이어가 로비에서 다른 플레이어에게 매치를 요청하고, 상대방이 이를 수락하여 매치가 시작됩니다.
    *   **액터:** 플레이어 A (요청자), 플레이어 B (수락자), 시그널링 서버.
    *   **사전 조건:** 플레이어 A와 B 모두 로비에 접속해 있습니다.
    *   **기본 흐름:**
        1.  플레이어 A가 로비에서 플레이어 B를 선택하고 매치 요청 버튼을 클릭합니다.
2.  클라이언트 A가 `request_match` 메시지를 시그널링 서버로 전송합니다. **(sessionId 포함)**
3.  시그널링 서버가 클라이언트 B에게 `match_request_received` 메시지를 전송합니다. **(sessionId 포함)**
4.  클라이언트 B가 매치 요청 알림을 받고 수락 버튼을 클릭합니다。
5.  클라이언트 B가 `accept_match` 메시지를 시그널링 서버로 전송합니다. **(sessionId 포함)**
6.  시그널링 서버가 클라이언트 A에게 `match_request_accepted` 메시지를 전송합니다. **(sessionId 포함)**
7.  클라이언트 A와 B가 WebRTC 핸드셰이크를 시작하고 P2P 연결을 수립합니다。
8.  시그널링 서버가 `match_started` 메시지를 전송하고 역할을 종료합니다. **(sessionId 포함)**
        9.  클라이언트 A와 B가 게임 화면으로 전환됩니다.
    *   **사후 조건:** 플레이어 A와 B 사이에 P2P 연결이 수립되고 게임이 시작됩니다.

*   **UC-003: 저지연 게임 플레이**
    *   **설명:** P2P 연결이 수립된 두 플레이어가 롤백 넷코드를 통해 저지연으로 게임을 플레이합니다.
    *   **액터:** 플레이어 A, 플레이어 B, 게임 엔진.
    *   **사전 조건:** 플레이어 A와 B 사이에 P2P 연결이 수립되고 게임이 시작되었습니다.
    *   **기본 흐름:**
        1.  플레이어 A가 입력 (예: 펀치)을 수행합니다.
        2.  클라이언트 A의 게임 엔진은 즉시 로컬 시뮬레이션을 업데이트하고 화면에 표시합니다.
        3.  클라이언트 A는 해당 입력을 `GameInput` 데이터 채널을 통해 클라이언트 B에게 전송합니다.
        4.  클라이언트 B의 게임 엔진은 클라이언트 A의 입력을 예측하여 시뮬레이션을 진행합니다.
        5.  클라이언트 B가 클라이언트 A의 실제 입력을 수신합니다.
        6.  클라이언트 B의 게임 엔진은 예측과 실제 입력을 비교합니다.
        7.  불일치 발생 시, 클라이언트 B의 게임 엔진은 롤백을 수행하고 재시뮬레이션하여 상태를 동기화합니다.
        8.  클라이언트 A와 B는 지속적으로 입력을 교환하고 시뮬레이션을 동기화하며 게임을 진행합니다.
    *   **사후 조건:** 두 플레이어가 네트워크 지연을 최소화하며 동기화된 게임 경험을 합니다.

*   **UC-004: 매치 종료 및 결과 표시**
    *   **설명:** 게임 내 조건에 따라 매치가 종료되고, 플레이어에게 결과가 표시됩니다.
    *   **액터:** 플레이어 A, 플레이어 B, 게임 엔진.
    *   **사전 조건:** 게임이 진행 중입니다.
    *   **기본 흐름:**
        1.  게임 엔진이 승리 조건 (예: 한 플레이어의 체력 고갈)을 감지합니다.
        2.  `GameStateSync` 채널을 통해 "K.O." 이벤트 메시지가 교환됩니다.
        3.  클라이언트 A와 B는 게임 플레이를 중단하고 매치 결과 화면으로 전환됩니다.
        4.  클라이언트 A와 B는 `RTCPeerConnection`을 종료합니다.
        5.  클라이언트 A와 B는 시그널링 서버에 다시 연결하여 로비로 돌아갈 수 있습니다.
    *   **사후 조건:** 매치가 종료되고 결과가 표시되며, 플레이어는 로비로 돌아갈 준비가 됩니다.

**2.2. 예외 및 에러 처리 유스 케이스**

*   **UC-E01: 매치 요청 거절**
    *   **설명:** 플레이어 A가 플레이어 B에게 매치를 요청했으나, 플레이어 B가 이를 거절합니다.
    *   **기본 흐름:** UC-002의 1~3단계 후, 클라이언트 B가 `decline_match` 메시지를 전송합니다. **(sessionId 포함)** 시그널링 서버는 클라이언트 A에게 `match_request_declined` 메시지를 전송하고, 양측 클라이언트는 로비 상태를 유지합니다.

*   **UC-E02: NAT 통과 실패 (TURN 서버 폴백)**
    *   **설명:** 두 클라이언트 간에 직접적인 P2P 연결 (STUN)이 불가능하여 TURN 서버를 통한 릴레이 연결이 사용됩니다.
    *   **기본 흐름:** UC-002의 7단계 (WebRTC 핸드셰이크) 중, ICE 프레임워크가 STUN 후보를 통해 직접 연결을 수립하지 못합니다. ICE는 자동으로 TURN 서버 후보를 시도하고, TURN 서버를 통해 데이터 릴레이 연결을 수립합니다.
    *   **사후 조건:** P2P 연결이 TURN 서버를 통해 수립되지만, 직접 연결보다 약간의 지연 시간이 추가될 수 있습니다. 클라이언트는 연결 유형 (직접/릴레이)을 인지하고 사용자에게 알릴 수 있습니다. **(연결 실패 시 자동 ICE restart 루틴 필수)**

*   **UC-E03: P2P 연결 끊김**
    *   **설명:** 게임 플레이 중 P2P 연결이 예기치 않게 끊어집니다.
    *   **기본 흐름:** `RTCPeerConnection`의 `iceconnectionstate`가 `disconnected` 또는 `failed`로 변경됩니다. 클라이언트는 `Metadata` 채널 (또는 연결 끊김 감지 로직)을 통해 상대방에게 연결 끊김을 알리거나, 타임아웃 처리 후 매치를 종료합니다.
    *   **사후 조건:** 매치가 종료되고, 연결 끊김 메시지가 표시됩니다. **(ICE connection state listener에서 자동 재시도 정책과 UX 피드백 구현)**

*   **UC-E04: 게임 비동기화 (Desynchronization)**
    *   **설명:** 두 클라이언트의 게임 상태가 서로 달라지는 비동기화가 발생합니다.
    *   **기본 흐름:** `GameStateSync` 채널을 통해 교환되는 주기적인 체크섬이 일치하지 않음을 감지합니다.
    *   **사후 조건:** 비동기화가 감지되면, 게임은 매치를 중단하고 오류 메시지를 표시하거나, 복구 로직 (예: 강제 재동기화 시도)을 실행할 수 있습니다.

*   **UC-E05: 시그널링 서버 연결 실패/끊김**
    *   **설명:** 클라이언트가 시그널링 서버에 연결하지 못하거나, 연결이 끊어집니다.
    *   **기본 흐름:** 클라이언트의 WebSocket 연결이 실패하거나 종료됩니다. 클라이언트는 재연결을 시도하거나, 오류 메시지를 표시하고 로비 진입을 실패합니다.
    *   **사후 조건:** 플레이어가 로비에 접속할 수 없거나, 로비 기능 (매치메이킹)을 사용할 수 없습니다.

---
