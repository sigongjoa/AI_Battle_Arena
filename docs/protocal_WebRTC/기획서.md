### **WebRTC 및 롤백 넷코드 기반 저지연 P2P 격투 게임 아키텍처 전환 계획**

**목표:** 현재 gRPC 기반의 통신 프로토콜을 WebRTC P2P 데이터 채널 및 롤백 넷코드 기반의 저지연 아키텍처로 전환하여, 격투 게임에 최적화된 온라인 경쟁 경험을 제공합니다.

**주요 변경 사항:**
*   **통신 방식:** 중앙 서버 경유 gRPC -> 클라이언트 간 직접 WebRTC P2P 데이터 채널
*   **상태 동기화:** 지연 기반 -> 롤백 넷코드 기반 결정론적 시뮬레이션
*   **서버 역할:** 게임 로직 처리 및 데이터 중계 -> 매치메이킹 및 시그널링 (일시적 역할)

---

**핵심 우선순위 (P0 PoC - Proof-of-Concept)**

전체 구현에 앞서, 다음 세 가지 핵심 PoC를 **수치로** 통과시키는 것이 가장 중요합니다. 이들이 실패하면 아키텍처의 근본적인 재검토가 필요합니다.

1.  **결정론 PoC:** 샌드박스 환경에서 규격 캐릭터 1명(충돌 없음, 점프/이동만)으로 로컬/원격 리플레이가 비트 단위로 동일한지 검증. (결정론 해시 동일)
2.  **롤백 루프 PoC:** 120ms 왕복 지연을 가정했을 때, 6~8프레임 롤백 재시뮬레이션이 16.67ms(60FPS 기준) 내에 안정적으로 완료되는지 검증.
3.  **WebRTC PoC:** TURN 서버를 포함하여 크롬/파이어폭스 상호 교차 테스트, Linux ↔ Windows ↔ Mac 환경에서 95% 이상의 연결 성공률 및 지표 수집.

---

**단계별 구현 계획 (강화된 우선순위 및 고려사항 포함)**

**1단계: 아키텍처 이해 및 초기 환경 설정**

1.  **기존 gRPC 구현 분석:**
    *   `backend/` 디렉토리 내 gRPC 서버 (`grpc_server.py`, `game_pb2.py`, `training_pb2.py` 등)의 데이터 교환 방식 및 게임 상태 관리 로직을 상세히 분석합니다.
    *   `arcade-clash/src/grpc/` 디렉토리 내 클라이언트 코드 (`client.ts`, `game_connect.ts` 등)에서 gRPC를 통해 어떤 데이터가 송수신되는지 파악합니다.
    *   현재 게임 로직 (`src/game.py`, `src/fighting_env.py` 등)이 어떻게 네트워크 입력과 상호작용하는지 이해합니다.
2.  **기술 스택 선정 및 라이브러리 조사:**
    *   **WebRTC 라이브러리:**
        *   **프론트엔드 (`arcade-clash`):** JavaScript/TypeScript용 WebRTC API 활용 방안 및 관련 라이브러리 (예: `PeerJS` 등) 조사.
        *   **백엔드 (시그널링/TURN):** Python 또는 Node.js 기반의 WebRTC 시그널링 서버 구현을 위한 라이브러리 (예: `websockets` for Python, `ws` or `socket.io` for Node.js) 조사.
    *   **롤백 넷코드 라이브러리:** 기존 게임 엔진에 통합 가능한 롤백 넷코드 라이브러리 (예: GGPO, Fightcade의 GGPO 포크 등) 조사 또는 커스텀 구현의 필요성 검토.
3.  **개발 환경 설정:** 필요한 라이브러리 설치 및 개발 환경 구성.

**2단계: 시그널링 서버 구현 (백엔드) - P1**

1.  **시그널링 프로토콜 설계:**
    *   WebRTC Offer/Answer 모델 및 ICE 후보 교환을 위한 WebSocket 기반 메시지 포맷을 정의합니다.
    *   매치메이킹 및 로비 로직을 위한 메시지 구조를 설계합니다.
    *   **추가 고려사항:** 각 매치에 `세션ID (nonce)` 도입, 모든 SDP/ICE 메시지에 `세션ID` 필수 포함. 상태 머신 기반의 전이 검증 (예: Requested → Accepted → Connecting → Connected 이외 전이 거부).
2.  **시그널링 서버 개발:**
    *   Node.js (권장) 또는 Python을 사용하여 WebSocket 기반 시그널링 서버를 구현합니다.
    *   플레이어 연결 관리, 게임 룸 생성/참여, SDP 및 ICE 메시지 중계 기능을 구현합니다.
    *   보안을 위해 WSS(WebSocket Secure)를 적용합니다.
    *   **추가 고려사항:** `WebSocket 인증` (최소 짧은 수명의 토큰 검증, 룸 참가 권한 체크). `오류/혼잡 제어` (로비 업데이트 디바운스, 스냅샷 주기 제한, 연결별 백프레셔 큐 및 드롭 정책).
3.  **STUN/TURN 서버 통합:**
    *   공용 STUN 서버를 활용하거나, 자체 STUN 서버를 설정합니다.
    *   TURN 서버 (예: `coturn`)를 배포하고 시그널링 서버와 연동하여 Symmetric NAT 환경의 연결을 지원합니다. **(P0 WebRTC PoC의 필수 요소)**

**3단계: WebRTC P2P 연결 및 데이터 채널 구현 (프론트엔드 - `arcade-clash`) - P1**

1.  **WebRTC 연결 관리:**
    *   `RTCPeerConnection` 객체 생성 및 관리 로직을 구현합니다.
    *   SDP Offer/Answer 생성 및 교환, ICE 후보 수집 및 전송 로직을 구현합니다.
    *   연결 상태 변화 (`iceconnectionstatechange`)를 처리하고 사용자에게 피드백을 제공합니다.
    *   **추가 고려사항:** `네트워크 변경 이벤트` (Wi-Fi ↔ LTE 전환, 절전 해제 등) 발생 시 ICE connection state listener에서 자동 재시도 정책 (재제안/ICE restart)과 UX 피드백 (“재연결 중…”) 구현.
2.  **다중 데이터 채널 구현:**
    *   `RTCDataChannel`을 사용하여 다음 채널들을 생성하고 구성합니다:
        *   `GameInput`: 비신뢰성, 비순서 (`ordered: false, maxRetransmits: 0`) - 플레이어 입력 전송.
        *   `GameStateSync`: 신뢰성, 순서 (`ordered: true`) - 초기 게임 상태, 주기적 상태 체크섬, 중요 이벤트 (K.O., 라운드 시작 등) 전송.
        *   `Metadata`: 신뢰성, 순서 (`ordered: true`) - 채팅 메시지, 연결 끊김 알림 등.
    *   각 채널을 통해 전송될 데이터의 직렬화/역직렬화 로직을 구현합니다.
    *   **추가 고려사항:**
        *   **`GameInput` 채널:** `unreliable/unordered`의 착각 방지 (브라우저별 구현 차이로 인한 지터 스파이크). 입력 배치 크기 상한 (예: 2~3프레임분까지만 묶기), 송신 측 최소 인터벌 (예: 4ms) 강제, 수신측 지터버퍼 (최대 2프레임) 도입. `DataChannel.bufferedAmount` 감시해 백프레셔 처리 (임계치 넘으면 간격 늘리기).
        *   **`GameStateSync` 채널:** `SCTP 스트림 단위 HoL` 회피. 메시지 MTU 하향 (≤ 1200 bytes), 큰 페이로드는 조각-식별자 붙여 다중 스트림 분산.
        *   **데이터 직렬화 드리프트:** 버전 필드 + 엄격 스키마 (예: protobuf/msgpack + 런타임 검증).
        *   **데이터 채널 라우팅 계층:** `DataChannel 3분할` (Input / State / Meta)에 대한 실제 라우팅 계층 (메시지 디스패처) 구현.

**4단계: 롤백 넷코드 통합 (게임 엔진 - `src` 및 `arcade-clash`) - P0**

1.  **결정론적 게임 엔진으로의 전환:** **(P0 결정론 PoC의 핵심)**
    *   **고정소수점(Fixed-Point) 수학:** 게임 로직 내 모든 부동소수점 연산을 고정소수점 연산으로 전환하는 방안을 검토하고 구현합니다. (가장 힘든 파트, 반드시 먼저 Proof-of-Concept).
    *   **난수 생성:** 모든 난수 생성기가 동일한 시드로 초기화되고 동일한 시퀀스를 생성하도록 보장합니다. 난수 호출 위치 금지 규약 (“시뮬 단계에서만 호출”, 렌더단 금지).
    *   **고정 타임스텝:** 렌더링 프레임 속도와 독립적으로, 고정된 타임스텝(예: 60 FPS)으로 게임 로직이 실행되도록 게임 루프를 수정합니다.
2.  **효율적인 게임 상태 관리 (저장 및 로드):** **(P0 롤백 루프 PoC의 핵심)**
    *   매 프레임마다 게임의 핵심 상태(캐릭터 위치, 체력, 입력 기록 등)를 효율적으로 스냅샷하고 저장하는 메커니즘을 구현합니다.
    *   저장된 상태를 빠르게 로드하여 게임을 특정 프레임으로 되돌릴 수 있는 기능을 구현합니다.
    *   렌더링 관련 데이터(모델, 텍스처 등)와 핵심 게임 상태를 분리하여 저장/로드 오버헤드를 최소화합니다.
    *   **추가 고려사항:** `상태 스냅샷 비용 폭발` 완화. 상태-표현 분리 + 구조체화 (plain arrays, typed arrays), 풀링으로 GC 제로화 지향. 스냅샷 링버퍼 (예: 최근 15~20프레임) + dirty-bit 기반 얕은 복사. “한 프레임 비용 C, 허용 롤백 N: N×C < 16.67ms”를 프로파일 숫자로 고정해, 매 빌드마다 예산 초과 시 경고.
3.  **롤백 넷코드 게임 루프 구현:** **(P0 롤백 루프 PoC의 핵심)**
    *   `local_frame`, `remote_frame`, `sync_frame` 등 여러 프레임 카운터를 관리하도록 게임 루프를 수정합니다.
    *   상대방 입력 예측 로직을 구현합니다.
    *   실제 입력 도착 시 예측과의 불일치를 감지하고, `sync_frame`으로 롤백하여 재시뮬레이션하는 로직을 구현합니다.
    *   입력 버퍼링 및 지터 버퍼를 구현하여 네트워크 지터를 흡수합니다.
    *   **추가 고려사항:** `예측 실패 시 시각적 파손` 완화. 입력 예측은 ‘마지막 입력 유지’ + 위험 상황 휴리스틱 (점프/대쉬 직후 몇 프레임은 보수적으로). `연출 지연` (히트 이펙트 1~2프레임 지연)으로 롤백 흔적 은폐. 옵션형 고정 입력지연 (1~2f) 토글 제공.
    *   **브라우저/런타임 특이점:** `탭 백그라운드 스로틀링` 완화 (게임 시뮬은 Web Worker에서 고정 틱, 렌더만 메인스레드. 크로스 오리진 아이솔레이션 + SharedArrayBuffer 사용 고려). `GC 스파이크` 완화 (할당 프리 루프, 메시지 직렬화도 재사용 버퍼). `입력 수집 지연/키 고스팅` 완화 (Raw input 폴링 주기를 로직 틱과 동기화. 키 매트릭스 기반 입력 버퍼).
    *   **보안/치트:** `서명된 리플레이` + 서버 검증 매치 끝나고 샘플링 감사. 최소한 `해시체크/프레임별 체크섬`을 `GameStateSync`로 주기 교차 검증.

**5단계: 통합 및 테스트 - P1**

1.  **종합 시스템 통합:**
    *   프론트엔드 (`arcade-clash`)의 WebRTC P2P 클라이언트와 백엔드의 시그널링 서버를 연동합니다.
    *   게임 엔진의 롤백 넷코드와 WebRTC 데이터 채널을 통해 수신된 입력을 통합합니다.
2.  **광범위한 테스트:**
    *   **결정론 테스트:** 두 클라이언트가 동일한 입력으로 정확히 동일한 게임 상태를 유지하는지 철저히 테스트합니다. **(P0 결정론 PoC의 검증)**
    *   **네트워크 조건 테스트:** 다양한 네트워크 환경(높은 지연 시간, 패킷 손실, 다른 NAT 유형)에서 STUN/TURN 및 롤백 넷코드의 견고성을 테스트합니다. **(P0 WebRTC PoC의 검증)**
    *   **비동기화 디버깅:** 비동기화 발생 시 원인을 파악하고 디버깅할 수 있는 로깅 및 도구를 구현합니다.
    *   **성능 프로파일링:** 게임의 재시뮬레이션 비용을 프로파일링하여 `N * C < 16.67ms` 제약 조건을 만족하는지 확인하고 최적화합니다. **(P0 롤백 루프 PoC의 검증)**
    *   **추가 고려사항:** `되는 것처럼 보인다` 함정 방지 (시뮬 네트워크 프로파일 고정: 30ms/0%, 80ms/1%, 120ms/3% + 지터 10~30ms + 2초간 버스트 손실). `재현 불가 디싱크` 완화 (프레임별 체크섬 양방향 교차 검증 + 자동 재현 리플레이 저장. 실패 시 최초 불일치 프레임과 직전 스냅샷 자동 덤프). `카나리아 규칙` (매치 시작 직후 3초간 ‘상태-해시 핸드셰이크’로 결정론 확인. 실패 시 매치 중단+재시작 유도).

**6단계: 최적화 및 개선 - P1**

1.  **입력 지연 및 시각적 롤백 은폐:**
    *   선택적으로 1-2프레임의 고정 입력 지연을 도입하여 롤백 빈도를 줄이는 옵션을 구현합니다.
    *   롤백 발생 시 시각적/음향적 효과를 통해 사용자 경험을 개선합니다.
2.  **대역폭 관리:**
    *   필요시 상태 스냅샷에 델타 압축과 같은 기술을 적용하여 대역폭 사용량을 최적화합니다.
3.  **연결 상태 관리:**
    *   WebRTC 연결 끊김, 재연결 시도 등 다양한 연결 상태 변화를 사용자에게 명확하게 알리고 우아하게 처리합니다.

---

**예상되는 주요 난관 (강화된 관점)**

*   **결정론 강제:** 부동소수점 연산, 난수 생성, 물리 엔진 등 게임의 모든 요소에서 완벽한 결정론을 달성하는 것은 매우 어렵고 시간이 많이 소요되는 작업입니다. **(P0 결정론 PoC 실패 시 아키텍처 재검토)**
*   **상태 스냅샷 비용 및 롤백 성능:** 매 프레임 상태 저장/복원 및 재시뮬레이션의 성능은 게임의 반응성에 직접적인 영향을 미치며, `N * C < 16.67ms` 제약 조건을 만족하는 것이 매우 어렵습니다. **(P0 롤백 루프 PoC 실패 시 아키텍처 재검토)**
*   **WebRTC NAT 통과 및 연결 성공률:** 다양한 네트워크 환경에서 안정적인 P2P 연결을 보장하는 것은 복잡하며, TURN 서버 운영 비용과 함께 연결 성공률이 낮으면 게임 플레이 자체가 불가능해집니다. **(P0 WebRTC PoC 실패 시 아키텍처 재검토)**
*   **비동기화 디버깅:** 비동기화 버그는 재현하기 어렵고 원인을 찾기 매우 까다롭습니다. 결정론 테스트 러너와 상세한 로깅 시스템이 필수적입니다.
*   **브라우저/런타임 특이점:** 탭 백그라운드 스로틀링, GC 스파이크, 입력 수집 지연 등 브라우저 환경의 특성으로 인한 문제가 발생할 수 있으며, 이에 대한 완화책 구현이 필요합니다.
*   **보안 및 치트:** P2P 환경은 입력 위변조에 취약하므로, 체크섬, 서명된 리플레이 등 보안 메커니즘을 설계 단계부터 고려해야 합니다.

---

**결론 (진짜 핵심 요약)**

문서의 큰 방향은 맞습니다. 하지만 **“결정론 + 상태 스냅샷 성능 + 연결 성공률(TURN)”** 이 3축이 부실하면, 설계가 아무리 좋아도 실전에서 바로 무너집니다.

따라서 초반 목표는 멋진 전체 구현이 아니라 3가지 P0 PoC를 지표와 함께 **“수치로” 통과시키는 것**입니다:

*   **결정론 해시 동일**
*   **8프레임 롤백을 16.67ms 내 안정**
*   **교차 브라우저/망에서 95% 이상 연결 성공 (ICE+TURN)**

이 셋이 통과되면 나머지는 “품질” 문제라서 튜닝 가능합니다. 통과 못 하면 “구조적” 문제라 아키텍처를 다시 뜯어야 합니다.

---
