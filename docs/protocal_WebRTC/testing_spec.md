### **WebRTC 및 롤백 넷코드 아키텍처 테스트 명세서**

**목표:** WebRTC P2P 데이터 채널 및 롤백 넷코드 기반의 저지연 격투 게임 아키텍처의 품질, 기능성, 성능 및 안정성을 보장하기 위한 테스트 전략, 환경 설정, 실행 방법 및 성공 판단 기준을 정의합니다.

---

#### **1. 테스트 환경 설정**

성공적인 테스트를 위해서는 실제 운영 환경과 유사한 다양한 네트워크 조건을 시뮬레이션할 수 있는 환경 구축이 필수적입니다.

**1.1. 로컬 개발 환경**

*   **목적:** 개별 컴포넌트 및 모듈의 단위 테스트 및 초기 통합 테스트.
*   **구성:**
    *   **백엔드 (시그널링 서버):** Python (또는 Node.js) 개발 환경.
    *   **프론트엔드 (클라이언트):** TypeScript/React 개발 환경 (Vite 등).
    *   **STUN/TURN 서버:** 개발용 `coturn` 인스턴스 또는 공용 STUN 서버 사용.
*   **도구:**
    *   **테스트 프레임워크:** Jest/Vitest (프론트엔드), Pytest (백엔드).
    *   **코드 품질:** ESLint, Prettier (프론트엔드), Ruff, Black (백엔드).
    *   **타입 검사:** TypeScript 컴파일러 (`tsc`), Mypy (백엔드).

**1.2. 스테이징/통합 테스트 환경**

*   **목적:** 실제 네트워크 조건 및 여러 클라이언트 간의 통합 테스트.
*   **구성:**
    *   **시그널링 서버:** 실제 배포 환경과 유사한 서버 인스턴스.
    *   **STUN/TURN 서버:** 안정적인 운영용 `coturn` 인스턴스.
    *   **여러 클라이언트:** 최소 2대 이상의 물리적/가상 머신 또는 브라우저 인스턴스.
*   **도구:**
    *   **네트워크 에뮬레이션:** `tc` (Linux Traffic Control), `Network Link Conditioner` (macOS), `Clumsy` (Windows) 등을 사용하여 지연 시간, 패킷 손실, 대역폭 제한 등을 시뮬레이션.
    *   **브라우저 개발자 도구:** WebRTC 통계, 네트워크 모니터링.

**1.3. 결정론 테스트 환경**

*   **목적:** 게임 시뮬레이션의 완벽한 결정론을 검증.
*   **구성:** 동일한 입력 시퀀스를 사용하여 두 개 이상의 클라이언트에서 시뮬레이션을 병렬로 실행하고 상태를 비교할 수 있는 환경.
*   **도구:**
    *   **입력 기록/재생 시스템:** 특정 매치의 모든 플레이어 입력을 기록하고, 이를 사용하여 시뮬레이션을 정확히 재현할 수 있는 도구.
    *   **상태 체크섬 비교 도구:** 특정 프레임에서 두 클라이언트의 게임 상태 체크섬을 비교하여 불일치를 감지하는 도구.
    *   **결정론 테스트 러너:** 입력 로그만으로 처음부터 끝까지 양단 재시뮬레이션을 수행하고, 이진 탐색으로 최초 분기 프레임을 특정하여 상태 덤프를 비교하는 도구.

#### **2. 테스트 유형 및 전략**

**2.1. 단위 테스트 (Unit Tests)**

*   **대상:** `FixedPoint` 클래스, `GameEngine`의 `simulateFrame`, `saveState`, `loadState` 메서드, 시그널링 서버의 메시지 핸들러, 데이터 직렬화/역직렬화 함수 등 개별 함수 및 클래스.
*   **전략:** 각 컴포넌트가 독립적으로 올바르게 작동하는지 검증. Mocking을 사용하여 외부 의존성 제거.

**2.2. 통합 테스트 (Integration Tests)**

*   **대상:**
    *   **WebRTC 클라이언트 - 시그널링 서버:** `SignalingClient`와 `WebSocketServer` 간의 메시지 교환 (SDP, ICE) 및 매치메이킹 플로우.
    *   **WebRTC 클라이언트 - WebRTC 클라이언트:** 두 `WebRtcClient` 인스턴스 간의 P2P 연결 수립 및 데이터 채널 통신.
*   **전략:** 실제 또는 Mock된 시그널링 서버를 사용하여 클라이언트 간의 상호작용 검증.

**2.3. 종단 간 테스트 (End-to-End Tests)**

*   **대상:** 플레이어 로비 진입부터 매치 종료까지의 전체 게임 플로우.
*   **전략:**
    *   **자동화된 E2E:** Playwright, Cypress (프론트엔드) 등을 사용하여 여러 브라우저 인스턴스를 제어하며 전체 시나리오 자동화.
    *   **수동 테스트:** 다양한 네트워크 조건, NAT 유형, 브라우저 조합에서 실제 플레이어가 직접 플레이하며 사용자 경험 검증.

**2.4. 결정론 테스트 (Determinism Tests)**

*   **대상:** `GameEngine`의 핵심 시뮬레이션 로직.
*   **전략:**
    *   **입력 기록/재생:** 특정 매치의 모든 입력을 기록하고, 이 기록을 사용하여 두 클라이언트에서 시뮬레이션을 재현. 각 프레임마다 게임 상태 체크섬을 비교하여 불일치 여부 확인.
    *   **랜덤 시드 고정:** 모든 난수 생성기가 동일한 시드로 초기화되는지 확인.
    *   **부동소수점 검증:** `FixedPoint` 연산이 모든 환경에서 동일한 결과를 내는지 검증.

**2.5. 네트워크 조건 테스트 (Network Condition Tests)**

*   **대상:** WebRTC 연결의 안정성 및 롤백 넷코드의 견고성.
*   **전략:**
    *   **시뮬 네트워크 프로파일 고정:** 다음 프로파일을 사용하여 테스트를 수행합니다.
        *   (A) 30ms 지연 / 0% 패킷 손실
        *   (B) 80ms 지연 / 1% 패킷 손실
        *   (C) 120ms 지연 / 3% 패킷 손실 + 10~30ms 지터 + 2초간 버스트 손실
    *   **지연 시간:** 50ms, 100ms, 200ms 등 다양한 왕복 지연 시간 조건에서 테스트.
    *   **패킷 손실:** 1%, 5%, 10% 등 다양한 패킷 손실률 조건에서 테스트.
    *   **대역폭 제한:** 업로드/다운로드 대역폭을 제한하여 테스트.
    *   **NAT 유형:** Full Cone, Restricted Cone, Port Restricted Cone, Symmetric NAT 환경에서 P2P 연결 성공률 및 TURN 폴백 동작 테스트.

**2.6. 성능 테스트 (Performance Tests)**

*   **대상:** 롤백 재시뮬레이션 비용, CPU/메모리 사용량, 네트워크 대역폭 사용량.
*   **전략:**
    *   **롤백 비용 측정:** 롤백 발생 시 재시뮬레이션에 소요되는 시간을 측정하여 `N * C < 16.67ms` 제약 조건 충족 여부 확인.
    *   **CPU/메모리 프로파일링:** 게임 플레이 중 클라이언트 및 서버의 CPU/메모리 사용량을 모니터링.
    *   **네트워크 트래픽 분석:** 데이터 채널을 통한 데이터 전송량 및 효율성 분석.

#### **3. 테스트 진행**

**3.1. 테스트 프레임워크 및 실행**

*   **프론트엔드:**
    *   **단위/통합 테스트:** `npm test` 또는 `yarn test` (Jest/Vitest).
    *   **E2E 테스트:** `npm run e2e` (Playwright/Cypress).
*   **백엔드:**
    *   **단위/통합 테스트:** `pytest` 명령 실행.
*   **CI/CD 통합:** 모든 테스트는 Git Push 또는 Pull Request 시 CI/CD 파이프라인에서 자동으로 실행되도록 구성.

**3.2. 수동 테스트**

*   **목적:** 자동화하기 어려운 사용자 경험, 다양한 네트워크 환경, 버그 재현 등.
*   **진행:** QA 팀 또는 개발자가 직접 다양한 기기, 브라우저, 네트워크 조건에서 게임을 플레이하며 문제점 발견.

**3.3. 디버깅 도구 활용**

*   **브라우저 개발자 도구:** WebRTC 내부 통계 (`chrome://webrtc-internals`), 네트워크 탭, 콘솔 로그.
*   **서버 로그:** 시그널링 서버의 상세 로그를 통해 메시지 흐름 및 에러 확인.
*   **게임 내 디버그 정보:** 현재 프레임, 핑, 롤백 횟수, 예측 성공률 등 게임 관련 디버그 정보를 화면에 표시.

#### **4. 테스트 성공 판단 기준**

**4.1. 기능적 정확성**

*   모든 핵심 유스 케이스 (UC-001 ~ UC-004)가 예상대로 작동해야 합니다.
*   모든 예외 및 에러 처리 유스 케이스 (UC-E01 ~ UC-E05)가 정의된 대로 처리되어야 합니다.
*   매치메이킹, P2P 연결 수립, 데이터 채널 통신이 안정적으로 이루어져야 합니다.
*   **카나리아 규칙:** 매치 시작 직후 3초간 **‘상태-해시 핸드셰이크’**를 통해 결정론을 확인합니다. 실패 시 매치 중단 및 재시작을 유도합니다.

**4.2. 결정론**

*   동일한 입력 시퀀스에 대해 두 클라이언트의 게임 상태 체크섬이 항상 일치해야 합니다 (비동기화 발생 금지).
*   비동기화가 감지될 경우, 즉시 보고되고 원인을 파악해야 합니다.
*   **재현 불가 디싱크 완화:** 프레임별 체크섬 (핵심 상태만) 양방향 교차 검증 + 자동 재현 리플레이 저장. 실패 시 최초 불일치 프레임과 직전 스냅샷 자동 덤프.

**4.3. 성능**

*   **지연 시간:** P2P 연결 시 평균 왕복 지연 시간 (RTT)이 100ms 미만일 때, 플레이어가 체감하는 입력 지연이 최소화되어야 합니다.
*   **롤백 빈도:** 정상적인 네트워크 환경 (낮은 지연, 낮은 패킷 손실)에서 롤백 발생 빈도가 낮아야 하며, 사용자에게 거슬리지 않는 수준이어야 합니다.
*   **재시뮬레이션 비용:** 롤백 재시뮬레이션에 소요되는 시간이 다음 프레임 렌더링 시간 (예: 16.67ms)을 초과하지 않아야 합니다.
*   **CPU/메모리:** 게임 플레이 중 클라이언트 및 서버의 CPU/메모리 사용량이 허용 가능한 범위 내에 있어야 합니다.
*   **지표:** 롤백 빈도 (f/s), 평균/95p/99p 롤백 폭 (프레임 수), 입력 늦음률, DataChannel bufferedAmount p95, ICE 재시작 횟수/세션당.

**4.4. 안정성 및 견고성**

*   다양한 네트워크 조건 (높은 지연, 패킷 손실, NAT 유형)에서 P2P 연결 수립 성공률이 95% 이상이어야 합니다 (TURN 폴백 포함).
*   게임 플레이 중 예기치 않은 연결 끊김, 서버 오류 등으로 인해 클라이언트가 비정상 종료되거나 멈추는 현상이 없어야 합니다.
*   장시간 플레이 시 메모리 누수 등의 문제가 발생하지 않아야 합니다.

**4.5. 디버깅 용이성**

*   비동기화 발생 시, 원인을 파악하고 재현할 수 있는 충분한 로그 및 디버그 정보가 제공되어야 합니다.
*   입력 기록/재생 시스템이 안정적으로 작동하여 버그 재현 및 분석에 활용될 수 있어야 합니다.

---
