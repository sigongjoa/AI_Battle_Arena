# 프로젝트 코딩 컨벤션 및 개발 가이드라인

이 문서는 프로젝트 전반에 걸쳐 일관된 코드 품질을 유지하고, 효율적인 협업을 도모하며, AI 모델 개발의 특정 측면(하이퍼파라미터 튜닝, 상대 AI 고도화)에 대한 구체적인 가이드라인을 제공하기 위해 작성되었습니다.

## 1. 일반 코딩 컨벤션

### 1.1. Python (백엔드 및 강화학습)

*   **PEP 8 준수**: 모든 Python 코드는 [PEP 8](https://www.python.org/dev/peps/pep-0008/) 스타일 가이드를 엄격히 준수합니다. `flake8` 또는 `black`과 같은 린터/포매터를 사용하여 자동 검사 및 포매팅을 권장합니다.
*   **들여쓰기**: 4칸 공백을 사용합니다.
*   **변수 및 함수명**: `snake_case`를 사용합니다. (예: `my_variable`, `calculate_reward()`)
*   **클래스명**: `CamelCase`를 사용합니다. (예: `MyClass`, `FightingEnv`)
*   **상수**: 모두 대문자에 `_`로 구분합니다. (예: `MAX_HP`, `LEARNING_RATE`)
*   **주석**: 코드의 *왜(Why)*를 설명하는 데 집중하며, *무엇(What)*을 하는지는 코드를 통해 명확히 드러나도록 합니다. 복잡한 로직이나 비즈니스 규칙에 대한 설명을 추가합니다.
*   **타입 힌트**: Python 3.6+의 타입 힌트를 적극적으로 사용하여 코드의 가독성과 안정성을 높입니다.

### 1.2. TypeScript/React (프론트엔드)

*   **ESLint 및 Prettier**: `ESLint`와 `Prettier`를 사용하여 코드 스타일을 일관되게 유지하고 잠재적인 오류를 방지합니다.
*   **들여쓰기**: 2칸 공백을 사용합니다.
*   **변수 및 함수명**: `camelCase`를 사용합니다. (예: `myVariable`, `calculateDamage()`)
*   **컴포넌트명**: `PascalCase`를 사용합니다. (예: `MyComponent`, `CharacterSelect`)
*   **타입스크립트 활용**: `interface` 또는 `type`을 사용하여 데이터 구조를 명확히 정의하고, `any` 타입 사용을 최소화합니다.
*   **JSX/TSX**: 컴포넌트 로직과 마크업을 분리하여 가독성을 높입니다.

## 2. Import 구조

### 2.1. Python

*   **그룹화**: 임포트는 다음 순서로 그룹화합니다.
    1.  표준 라이브러리 임포트 (예: `os`, `sys`)
    2.  서드파티 라이브러리 임포트 (예: `numpy`, `stable_baselines3`)
    3.  로컬 애플리케이션/라이브러리 특정 임포트
*   **정렬**: 각 그룹 내에서는 알파벳 순서로 정렬합니다.
*   **절대 임포트 우선**: 상대 임포트(`from . import module`)보다는 절대 임포트(`from my_package import module`)를 선호합니다.

### 2.2. TypeScript/React

*   **그룹화**: 임포트는 다음 순서로 그룹화합니다.
    1.  내장 모듈 (예: `react`)
    2.  서드파티 라이브러리
    3.  프로젝트 내부 모듈 (절대 경로 사용)
    4.  상대 경로 모듈
*   **정렬**: 각 그룹 내에서는 알파벳 순서로 정렬합니다.

## 3. 하이퍼파라미터 튜닝 전략

강화학습 모델의 성능을 최적화하기 위해 체계적인 하이퍼파라미터 튜닝 전략을 수립합니다.

*   **튜닝 대상 하이퍼파라미터**: 초기에는 다음 핵심 하이퍼파라미터에 집중합니다.
    *   `learning_rate`: 학습률 (AI가 얼마나 빠르게 학습하는지)
    *   `batch_size`: 배치 크기 (한 번에 처리하는 경험 데이터의 양)
    *   `gamma`: 감가율 (미래 보상에 대한 현재 가치)
    *   `n_steps`: 스텝 수 (환경과 상호작용하는 스텝 수)
    *   `ent_coef`: 엔트로피 계수 (탐험과 활용의 균형)
*   **최적화 방법**: 초기 탐색을 위해 `Grid Search` 또는 `Random Search`를 활용하고, 유망한 영역을 찾은 후에는 `Bayesian Optimization` (예: Optuna, Hyperopt)과 같은 고급 방법을 사용하여 효율적으로 최적화합니다.
*   **실험 관리**: 각 튜닝 실험은 명확한 이름과 함께 기록하고, 사용된 하이퍼파라미터, 결과 모델, TensorBoard 로그를 체계적으로 관리합니다.
*   **재현성**: 모든 튜닝 실험은 재현 가능하도록 `seed` 값을 고정하고, 환경 및 모델 설정을 명확히 문서화합니다.

## 4. 상대 AI 고도화 전략

AI 파이터가 특정 상대에게만 과적합되는 것을 방지하고, 더욱 강하고 일반화된 성능을 갖도록 상대 AI 고도화 전략을 수립합니다.

*   **상대 AI 풀(Pool) 구축**: 다양한 전략과 난이도를 가진 상대 AI 풀을 구축합니다.
    *   **규칙 기반 AI**: 기본적인 움직임과 공격 패턴을 가진 AI.
    *   **이전 버전의 학습된 AI**: 과거에 훈련된 다양한 성능의 AI 모델.
    *   **무작위 행동 AI**: 탐험을 유도하기 위한 무작위 행동 AI.
    *   **미러링 AI**: 플레이어의 행동을 모방하는 AI (과적합 방지).
*   **주기적인 상대 교체 학습**: AI 훈련 시, 고정된 상대 AI와만 대전하는 것이 아니라, 상대 AI 풀 내에서 주기적으로 상대를 교체하며 학습을 진행합니다. (예: 일정 에피소드마다 상대 AI 변경, 상대 AI 풀 내에서 무작위 선택)
*   **커리큘럼 학습**: 쉬운 상대부터 시작하여 점진적으로 어려운 상대를 만나도록 커리큘럼 학습 방식을 도입하여 AI의 학습 효율을 높입니다.
*   **평가 지표**: 다양한 상대 AI에 대한 승률, 평균 데미지, 방어 성공률 등 다각적인 평가 지표를 사용하여 AI의 일반화 성능을 측정합니다.
