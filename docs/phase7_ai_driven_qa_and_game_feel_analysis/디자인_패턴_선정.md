# Phase 7: 디자인 패턴 선정 (v2.0)

## 1. 목적

본 문서는 AI 기반 자동 QA 시스템의 **고도화된 아키텍처** 개발에 있어 코드의 유연성, 확장성, 그리고 유지보수성을 향상시키기 위해 적용할 주요 디자인 패턴을 정의한다.

## 2. 적용할 디자인 패턴 (v2.0)

### 2.1. 파이프라인 패턴 (Pipeline Pattern)
- **적용 대상:** 시스템 전체 아키텍처
- **선정 이유:** (v1.0과 동일) 데이터 처리 과정을 여러 개의 독립적인 단계로 나누어 시스템의 구조를 단순하고 명확하게 만든다.
- **구현:** (v1.0과 동일)

### 2.2. 전략 패턴 (Strategy Pattern)
- **(확장) 적용 대상:**
  - `RL Agent`의 **페르소나(Persona)** 교체
  - `RL Agent`의 보상 함수(Reward Function) 교체
  - `QA Evaluator AI`의 평가 로직
- **선정 이유:**
  - **(핵심)** 테스트 목적에 따라 알고리즘을 동적으로 교체할 수 있게 한다. 이는 **v2.0의 핵심 요구사항인 '다각적 분석'을 구현하는 데 필수적이다.**
  - **페르소나 교체:** `BeginnerStrategy`, `ProGamerStrategy`, `TrollStrategy` 등을 구현하여, 동일한 에이전트 프레임워크에서 페르소나만 교체하며 시뮬레이션할 수 있다.
  - **보상 함수 교체:** `WinFocusedReward`, `CuriosityReward`, `DisruptionReward` 등 다양한 보상 전략을 독립적으로 개발하고 테스트할 수 있다.
- **구현:** 페르소나, 보상 함수 등을 공통 인터페이스(추상 기본 클래스)로 정의하고, 컨텍스트(에이전트)가 실행 시점에 구체적인 전략 클래스를 주입받아 사용하도록 구현한다.

### (추가) 2.3. 데코레이터 패턴 (Decorator Pattern)
- **적용 대상:** **'인간적 실수 레이어(Human Error Layer)' 구현**
- **선정 이유:**
  - 기존 AI 에이전트의 핵심 로직을 전혀 수정하지 않으면서, 동적으로 '인간적 실수'라는 새로운 책임을 추가할 수 있다.
  - `Action` 객체를 여러 데코레이터(예: `InputLagDecorator`, `InputMistakeDecorator`)로 감싸는(wrapping) 방식으로, 다양한 종류의 실수를 조합하거나 순서를 변경하는 것이 매우 유연하다.
  - 기능의 ON/OFF가 간편하여, '완벽한 AI'와 '실수하는 AI'의 성능을 쉽게 비교 테스트할 수 있다.
- **구현:** `BaseAction` 인터페이스를 구현하는 `ConcreteAction` 클래스와, 동일한 인터페이스를 구현하며 `BaseAction` 객체를 멤버로 가지는 `ActionDecorator` 추상 클래스를 만든다. `InputLagDecorator` 등 구체적인 데코레이터들은 `ActionDecorator`를 상속받아 `execute()` 메소드 호출 전후에 실수를 주입하는 로직을 추가한다.

### 2.4. 옵저버 패턴 (Observer Pattern)
- **적용 대상:** `Simulation Arena` (Subject) 와 `Log Collector` (Observer)
- **선정 이유:** (v1.0과 동일) 게임 시뮬레이션에서 발생하는 이벤트를 다른 모듈과 느슨하게 결합(Loose Coupling)된 상태로 전파할 수 있게 한다.
- **구현:** (v1.0과 동일)

### 2.5. 퍼사드 패턴 (Facade Pattern)
- **적용 대상:** `Report Generator`의 영상 생성 모듈
- **선정 이유:** (v1.0과 동일) 복잡한 영상 생성 서브시스템(TTS, 3D 렌더링, 인코딩, **XAI 근거 클립 추출**)을 단순화된 단일 인터페이스로 감싸, 클라이언트의 사용을 용이하게 한다.
- **구현:** (v1.0과 동일)

### 2.6. 템플릿 메소드 패턴 (Template Method Pattern)
- **적용 대상:** `Report Generator`의 리포트 생성 로직
- **선정 이유:** (v1.0과 동일) 리포트 생성의 전체적인 구조는 통일하되, 세부 내용(밸런스, 안정성 등)은 하위 클래스에서 다양하게 구현할 수 있게 하여 코드 중복을 줄이고 일관성을 유지한다.
- **구현:** (v1.0과 동일)
